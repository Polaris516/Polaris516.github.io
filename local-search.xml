<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SpringBoot框架学习</title>
    <link href="/SpringBoot%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    <url>/SpringBoot%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Springboot-系统学习开发"><a href="#Springboot-系统学习开发" class="headerlink" title="Springboot 系统学习开发"></a>Springboot 系统学习开发</h1><p><img src="D:/ProgramData/Myblog/source/_posts/assets/image-20241220110617829.png" alt="image-20241220110617829"></p><p><img src="D:/ProgramData/Myblog/source/_posts/assets/image-20241220110626329.png" alt="image-20241220110626329"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Uni-app 开发学习</title>
    <link href="/Uni-app-%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    <url>/Uni-app-%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Uniapp-学习"><a href="#Uniapp-学习" class="headerlink" title="Uniapp 学习"></a>Uniapp 学习</h1><h2 id="博客前瞻"><a href="#博客前瞻" class="headerlink" title="博客前瞻"></a>博客前瞻</h2><p>​在本博客的内容就是学习Uniapp开发，通过Android studio学习Android app的开发到Uniapp的开发再到未来的Harmony app开发，我们进行到了第二步。</p><p>​这里的Uniapp的开发需要用到的东西有：<code>Hbuilder X</code>（开发工具）、Vue3、以及编写小程序的开发工具（微信小程序，抖音小程序等等可以自行安装）</p><p>​学习Uniapp开发需要具备一些基础知识：Vue3</p><p>​如果需要后续会将环境安装等教程以博客链接的形式上传到本博客中，大家可以自行消化。</p><h2 id="基础知识（必备）"><a href="#基础知识（必备）" class="headerlink" title="基础知识（必备）"></a>基础知识（必备）</h2><h3 id="Vue3入门学习"><a href="#Vue3入门学习" class="headerlink" title="Vue3入门学习"></a>Vue3入门学习</h3><p><a href="https://cn.vuejs.org/guide/quick-start.html">Vue官方文档</a></p><p>以下的内容我们将以Uniapp中的Vue写作方法为主：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;UserInfoPlus&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;obj.avatar&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;avatar&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>&#123;&#123;obj.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toggleEdit&quot;</span>&gt;</span>编辑<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isEditing&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;isEditing&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;editedName&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;修改名字&quot;</span>/&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;editedAvatar&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;修改头像&quot;</span>/&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;submitChanges&quot;</span>&gt;</span>确定<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123;ref, computed&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&quot;update&quot;</span>]);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">obj</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">type</span>: <span class="hljs-title class_">Object</span>,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">default</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-attr">avatar</span>:<span class="hljs-string">&quot;&quot;</span>&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> (&#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">name</span>: props.<span class="hljs-property">obj</span>.<span class="hljs-property">name</span> || <span class="hljs-string">&quot;未知12138&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-attr">avatar</span>: props.<span class="hljs-property">obj</span>.<span class="hljs-property">avatar</span> || <span class="hljs-string">&quot;../../static/default_img.jpg&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;)); </span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 编辑逻辑处理</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> isEditing = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> editedName = <span class="hljs-title function_">ref</span>(props.<span class="hljs-property">obj</span>.<span class="hljs-property">name</span>);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> editedAvatar = <span class="hljs-title function_">ref</span>(props.<span class="hljs-property">obj</span>.<span class="hljs-property">avatar</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">toggleEdit</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">isEditing.<span class="hljs-property">value</span> = !isEditing.<span class="hljs-property">value</span>;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">submitChanges</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">isEditing.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;update&quot;</span>,&#123;<span class="hljs-attr">name</span>: editedName.<span class="hljs-property">value</span>, <span class="hljs-attr">avatar</span>: editedAvatar.<span class="hljs-property">value</span>&#125;);</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.UserInfoPlus</span>&#123;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-attribute">background</span>: <span class="hljs-number">#ccc</span>;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-attribute">display</span>: flex;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-attribute">align-items</span>: center;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-attribute">justify-content</span>: center;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-attribute">flex-direction</span>: column;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-tag">image</span>&#123;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.username</span>&#123;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">0</span>;</span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>uniapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Springboot + Scrapy + Vue的信息快检索平台</title>
    <link href="/DataWeb/"/>
    <url>/DataWeb/</url>
    
    <content type="html"><![CDATA[<p><code>本次博客内容先瞻：</code></p><span class="label label-primary">text</span>本次博客，我们要实现利用 Scrapy 框架对网站数据进行爬取后存储到MySQL数据库中，然后使用 Vue 写一个Web网站，最后利用 Springboot 框架编写后端接口，将数据库的内容渲染到网站，实现一个简单的信息快检索平台。]]></content>
    
    
    
    <tags>
      
      <tag>Springboot</tag>
      
      <tag>Vue</tag>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Compilers</title>
    <link href="/Compeilers/"/>
    <url>/Compeilers/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    
    <tags>
      
      <tag>Compilers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Organization</title>
    <link href="/ComputerOrganization/"/>
    <url>/ComputerOrganization/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><div class="note note-warning">            <p>本文是介绍计算机组成原理，覆盖408考点，但是着重点是以国外教材为主。</p>          </div><h2 id="第一章-概论"><a href="#第一章-概论" class="headerlink" title="第一章 概论"></a>第一章 概论</h2><p><img src="/img/C-O/1.1.png"></p><h3 id="1-1-计算机发展历程"><a href="#1-1-计算机发展历程" class="headerlink" title="1.1 计算机发展历程"></a>1.1 计算机发展历程</h3><h4 id="1-1-1-计算机的软硬件的概念"><a href="#1-1-1-计算机的软硬件的概念" class="headerlink" title="1.1.1 计算机的软硬件的概念"></a>1.1.1 计算机的软硬件的概念</h4><p>计算机系统由“硬件”和“软件”两大部分组成。</p><p>​硬件：计算机的实体部分，它由看得见摸得着的各种电子元器件，各类光、电、机设备的实物组成，如主机，外部设备等。</p><p>​软件：它看不见摸不着，由人们事先编制的具有各类特殊功能的程序组成。</p><h4 id="1-1-2计算机的发展"><a href="#1-1-2计算机的发展" class="headerlink" title="1.1.2计算机的发展"></a>1.1.2计算机的发展</h4><table><thead><tr><th>发展阶段</th><th>时间</th><th>逻辑元件</th><th>速度（次&#x2F;秒）</th></tr></thead><tbody><tr><td>一代</td><td>1946 - 1957</td><td>电子管</td><td>几千~几万</td></tr><tr><td>二代</td><td>1958 - 1964</td><td>晶体管</td><td>几万~几十万</td></tr><tr><td>三代</td><td>1964 - 1971</td><td>中小规模集成电路</td><td>几十万~几百万</td></tr><tr><td>四代</td><td>1972 - 今</td><td>大规模和超大规模集成电路</td><td>上千万~万亿</td></tr></tbody></table><p><strong>摩尔定律：</strong>集成电路上的晶体管数量每18个月就会翻一番，所以每18个月计算机的处理效率就会提高一倍。</p><blockquote><p>晶体管之父：肖克利（1956年诺贝尔物理学奖得主）</p><p>1957年，“八叛徒”创立了仙童半导体</p><p>1959年，仙童半导体发明了“集成电路”</p><p>1968年，摩尔离开仙童，创立intel</p><p>1969年，仙童销售部负责人桑德斯离开仙童，创立AMD</p></blockquote><h4 id="1-1-3-计算机的分类和发展方向"><a href="#1-1-3-计算机的分类和发展方向" class="headerlink" title="1.1.3 计算机的分类和发展方向"></a>1.1.3 计算机的分类和发展方向</h4><ul><li>电子模拟计算机和电子数字计算机<ul><li>电子数字计算机按用途分为2类：专用计算机、通用计算机<ul><li>通用计算机：巨型机、大型机、中型机、小型机、微型机和单片机6类</li></ul></li><li>按照指令和数据流分为：<ul><li>单指令流和单数据流系统（SISD），即传统的冯·诺依曼体系结构</li><li>单指令流和多数据流系统（SIMD），包括阵列处理器和向量处理器系统</li><li>多指令流和单数据流系统（MISD），这种计算机实际上不存在</li><li>多指令流和多数据流系统（MIMD），包括多处理器和计算机系统</li></ul></li></ul></li></ul><h3 id="1-2-计算机系统的层次结构"><a href="#1-2-计算机系统的层次结构" class="headerlink" title="1.2 计算机系统的层次结构"></a>1.2 计算机系统的层次结构</h3><p><strong>五个层级 三种语言 两种程序</strong></p><p><img src="/img/C-O/1.2.1.png"></p><h4 id="1-2-1-计算机系统的组成"><a href="#1-2-1-计算机系统的组成" class="headerlink" title="1.2.1 计算机系统的组成"></a>1.2.1 计算机系统的组成</h4><p>计算机系统由硬件系统和软件系统共同构建起来</p><h4 id="1-2-2-计算机硬件的基本构成"><a href="#1-2-2-计算机硬件的基本构成" class="headerlink" title="1.2.2 计算机硬件的基本构成"></a>1.2.2 计算机硬件的基本构成</h4><h5 id="1-早期的冯·诺依曼机"><a href="#1-早期的冯·诺依曼机" class="headerlink" title="1.早期的冯·诺依曼机"></a>1.早期的冯·诺依曼机</h5><blockquote><p>美籍匈牙利科学家冯·诺依曼最先提出“程序存储”的思想，并成功将其运用在计算机的设计之中，根据这一原理制造的计算机被称为冯·诺依曼结构计算机。由于他对现代计算机技术的突出贡献，因此冯·诺依曼又被称为“现代计算机之父”。</p><p><font color=blue>什么是存储程序原理？按此原理，计算机应具有哪几大功能？</font></p><p><font color=red>“程序存储”</font>：指令以代码的形式事先输入到计算机的主存储器中，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他程序，直至程序执行结束，即<font color="red">按地址访问并顺序执行指令</font></p><p>计算机按照此原理应具有5大功能：数据传送功能、数据存储功能、数据处理功能、操作控制功能、操作判断功能</p></blockquote><ul><li>冯·诺依曼体系结构特点<ol><li>计算机硬件系统由五大部件构成（存储器，运算器，控制器，输入设备，输出设备）</li><li>指令和数据以同等地位存于存储器，可按地址寻访</li><li>指令和数据用二进制表示</li><li>指令由操作码和地址码组成</li><li>存储程序</li><li>以运算器为中心</li></ol></li></ul><blockquote><p>早期的冯·诺依曼机以运算器为中心，且是单处理机，最根本的特征是采用“存储程序”原理，基本工作方式是<strong>控制流驱动方式</strong></p></blockquote><p><img src="/img/C-O/1.2.2.png"></p><h5 id="2-现代计算机的组织结构"><a href="#2-现代计算机的组织结构" class="headerlink" title="2.现代计算机的组织结构"></a>2.现代计算机的组织结构</h5><p><img src="/img/C-O/1.2.3.png"></p><h5 id="3-计算机的功能部件"><a href="#3-计算机的功能部件" class="headerlink" title="3.计算机的功能部件"></a>3.计算机的功能部件</h5><p>主机：主存、运算器、控制器</p><p><img src="/img/C-O/1.2.4.png"></p><p>五大部分：</p><ol><li><p>输入设备：是指将外部信息以计算机能读懂的方式输入进来，如键盘，鼠标等</p></li><li><p>输出设备：就是将计算机处理的信息以人所能接受的方式输出出来，比如显示屏，打印机</p></li><li><p>存储器，存储器主要分为<strong>主存储器</strong>（内存储器，CPU能直接访问）和<strong>辅助存储器</strong>（外存储器，协助主存储器记忆更多的信息，辅助存储器的信息需要导入到主存储器中，才能被CPU访问。</p><ul><li><strong>主存储器</strong>的工作方式是<font color=red>按存储单元的地址进行存取</font>，这种存取方式称为<strong>按地址存取方式</strong>（相联存储器既可以按照<strong>地址寻址</strong>，又可以按照<strong>内容寻址</strong>，为了与传统存储器区别，又称为<strong>内容寻址的存储器</strong>。</li><li>主存储器是由地址寄存器（MAR），数据寄存器（MDR），存储体，时序控制逻辑，地址寄存器存放访存地址，经过地址译码后找到所选的存储单元。数据寄存器，是存储器与其他部件的中介，用于暂存要从存储器读或写的信息。时序控制逻辑用于产生存储器操作所需的各种时序信号。在现代CPU中，MAR和MDR是在CPU中的。</li></ul><p> <img src="/img/C-O/1.2.5.png"></p></li><li><p>运算器：是计算机的运算单元，用于算数运算和逻辑运算，运算器的核心单元是算术逻辑单元（ALU）</p><p> <img src="/img/C-O/1.2.6.png"></p></li><li><p>控制器：是计算机的指挥中心，有其指挥各部件自动协调的进行工作，现代计算机将运算器和控制器集成到一个芯片上，合成中央处理器，简称CPU。有程序计数器（PC）、指令寄存器（IR）和控制单元（CU）</p><p> <img src="/img/C-O/1.2.7.png"></p></li></ol><p><font color=bule>一般将运算器和控制器集成到同一个芯片上，称为<strong>中央处理器（CPU）</strong>。<strong>CPU</strong>和<strong>主存储器</strong>共同构成主机，而除主机外的其他硬件装置（外存，I&#x2F;O设备等）统称为外部设备，即<strong>外设</strong>。</font></p><p>CPU和主存之间通过一组<strong>总线</strong>相连，总线中有<strong>地址、控制和数据3组信号线</strong>。MAR中的地址信息会直接送到地址线上，用于指向读&#x2F;写操作的主存存储单元；控制线中有读&#x2F;写信号线，指出数据是从CPU写入主存还是从主存读出到CPU，根据是读操作还是写操作来控制将MDR中的数据直接送到数据线上还是将数据线上的数据接收到MDR中。</p><h3 id="1-3-计算机软件的分类"><a href="#1-3-计算机软件的分类" class="headerlink" title="1.3 计算机软件的分类"></a>1.3 计算机软件的分类</h3><p>计算机软件，一般分为系统软件和应用软件</p><ul><li>系统软件包括 操作系统、数据库管理系统、语言处理系统（比如编译器）、分布式软件系统、网络软件系统、标准库系统、服务性系统（比特连接程序）</li><li>应用软件包括各种科学计算类程序，工程设计类程序，数据统计与处理程序</li></ul><p>注意：数据库管理系统和数据库系统是有区别的。数据库管理系统是系统软件。而数据库系统一般是由数据库，数据库管理系统，数据库管理员和应用系统构成。所以只能说它里面有系统软件，但并不能说它为系统软件。</p><p>2.三个级别的语言</p><ul><li>机器语言。又称二进制代码语言，需要编程人员记忆每条指令的二进制编码。<strong>机器语言是计算机唯一可以直接识别和执行的语言。</strong></li><li>汇编语言。汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编语言编辑的程序，必须经过一个称为汇编程序的系统软件的翻译，将其转换为计算机的机器语言后，才能在计算机的硬件系统上执行。</li><li>高级语言。高级语言(如C、C++、Java等)是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。</li><li>由高级语言转换到汇编语言的过程叫做<strong>编译</strong>，由汇编语言转换到机器语言的过程叫做<strong>汇编</strong>，边翻译边执行的叫做<strong>解析</strong>。</li></ul><p>机器语言是<strong>唯一</strong>可以控制cpu的语言，因为它的符号不利于人识别和书写，为了方便理解和记忆，将机器语言换一些通俗易懂的符号，这就变成了汇编语言。一般来说在在编译器中高级语言先转换为汇编在转换为机器语言，也有直接转换为机器语言的情况。</p><blockquote><p><font color=green>机器语言是计算机唯一可以直接执行的语言</font>，汇编语言用助记符编写，以便记忆。而正则语言是编译原理中符合正则文法的语言。</p><p>解释程序的特点是翻译一句执行一句，边翻译边执行：由高级语言转化为汇编语言的过程叫编译，把汇编语言翻译成机器语言的过程叫汇编。</p></blockquote><p>IR存放当下欲执行的指令；PC存放下一条指令的地址；</p><p>MAR存放欲访问的存储单元地址；MDR存放从存储单元取来的数据</p><p>地址译码器是主存的构成部分，不属于CPU；地址寄存器虽然一般属于主存，但是现代计算机中绝大多数CPU内集成了地址寄存器</p><p>关于CPU存取速度的比较：寄存器（CPU内部）&gt; Cache（高速的SRAM）&gt; 内存（SDRAM）</p><h3 id="1-4-计算机的性能指标"><a href="#1-4-计算机的性能指标" class="headerlink" title="1.4 计算机的性能指标"></a>1.4 计算机的性能指标</h3><p><img src="/img/C-O/1.3.1.png"></p><p><code>周期：1次需要多少s，频率：1s能完成多少次</code></p><p><strong>1.机器字长</strong>：</p><p>计算机的位数（机器字长），表示计算机一次整数运算（即定点整数运算）所能处理的二进制数据位数。计算机字长通常选定为（8位），通常是2,4,8倍。不同的计算机，字节可能不同</p><blockquote><p><font color=red>机器字长，指令字长，存储字长的区别和联系</font></p><ul><li>机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度</li><li>指令字长：一个指令字中包含的二进制代码的位数。</li><li><strong>存储字长</strong>：一个存储单元存储的二进制代码的长度。<strong>等于MDR的位数</strong>，他们都必须是字节的整数倍</li><li><strong>数据字长：数据总线一次能传送信息的位数，</strong>它可以不等于MDR的位数。</li></ul><p>指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令，因此取指周期为机器周期的2倍；若指令字长等于存储字长，则取指周期等于机器周期。</p><p>早期的计算机存储字长一般和机器的指令字长与数据字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍。</p><p>请注意64位操作系统是指特别为64位架构的计算机而设计的操作系统，它能够利用64位处理器的优势。但64位机器既可以使用64位操作系统，又可以使用32位操作系统。而32位处理器是无法使用64位操作系统的。</p></blockquote><p><strong>2.数据通路带宽</strong></p><p>数据总线一次所能传送信息的位数</p><p><strong>3.主存容量</strong></p><p>MAR的位数反映存储单元的个数，如MAR为16位，表示存储单元为$$2^{16} &#x3D; 64k$$;若MDR为32位，则存储容量为$$2^{16}*32 $$</p><p><strong>4.运算速度</strong></p><blockquote><p>吞吐量：指系统在单位时间内处理的请求；从用户观点看，它是评价计算机系统性能的综合参数</p><p>响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结构的等待时间</p></blockquote><blockquote><p>CPU时钟周期：通常为节拍脉冲或T周期，即主频的倒数，它是CPU中最小的时间单位，每个动作至少需要1个时钟周期。</p><p>主频（CPU时钟频率）：机器内部主时钟的频率，是衡量机器速度的重要参数。</p><ul><li>CPU周期又称为机器周期，由多个时钟周期组成</li><li>指令周期&gt;CPU周期&gt;时钟周期</li></ul></blockquote><blockquote><p><font color = red>CPI（Clock cycle Per Instruction)：即执行一条指令所需的时钟周期数</font></p></blockquote><blockquote><p>CPU执行时间，指运行一个程序所花费的时间</p><p><strong>CPU执行时间 &#x3D; CPU时钟周期&#x2F;主频 &#x3D; （指令条数 * CPI)&#x2F;主频</strong></p><p><strong>CPU的性能</strong>主要取决于三个因素：<strong>主频</strong>、<strong>CPI</strong>、<strong>指令条数</strong></p></blockquote><blockquote><p>IPS(Instructions Per Second) &#x3D;主频&#x2F;平均CPI，每秒执行多少指令</p><p>MIPS(Million Instructions Per Second)&#x3D;即每秒执行多少百万条指令。</p><p>MFLOPS(Mega Floating-point Operations Per Second)&#x3D;浮点操作次数&#x2F;(执行时间x106),即每秒执行多少百万次浮点运算。</p><p>GFLOPS(Giga Floating-point Operations Per Second)&#x3D;浮点操作次数&#x2F;(执行时间x109)，即每秒执行多少十亿次浮点运算。</p><p>TFLOPS(Tera Floating-point Operations Per Second)&#x3D;浮点操作次数&#x2F;(执行时间x1012)，即每秒执行多少万亿次浮点运算</p></blockquote><h2 id="第二章-数据的运算和表示"><a href="#第二章-数据的运算和表示" class="headerlink" title="第二章 数据的运算和表示"></a>第二章 数据的运算和表示</h2><p><img src="/img/C-O/2.1.png"></p><h3 id="2-1-数制与编码"><a href="#2-1-数制与编码" class="headerlink" title="2.1 数制与编码"></a>2.1 数制与编码</h3><h4 id="2-1-1进位计数制及其相互转换"><a href="#2-1-1进位计数制及其相互转换" class="headerlink" title="2.1.1进位计数制及其相互转换"></a>2.1.1进位计数制及其相互转换</h4><p><img src="/img/C-O/2.1.1.png"></p><h4 id="2-1-2-机器数与真值"><a href="#2-1-2-机器数与真值" class="headerlink" title="2.1.2 机器数与真值"></a>2.1.2 机器数与真值</h4><p><strong>机器数：</strong>把符号“数字化”的数称为机器数。<code>将“符号-&gt;数字化”的数，一般为二进制数，比如带符号位的4位二进制数0110，最高位8就是符号位，这个数的真值就是+6</code></p><p><strong>真值</strong>：带“+”或”-“符号的数称为真值。<code>比如：+5、+7。真值是机器数所代表的实际值，一般为十进制数</code></p><h4 id="2-1-3-什么是BCD码？"><a href="#2-1-3-什么是BCD码？" class="headerlink" title="2.1.3 什么是BCD码？"></a>2.1.3 什么是BCD码？</h4><ul><li>简单来说，就是用<code>4位二进制数表示1位十进制数（0~9），是一种二进制的数字编码形式，用二进制编码来替代十进制代码</code></li><li>BCD码可分成两类：<strong>有权码</strong>和<strong>无权码</strong>。</li><li>为什么使用BCD码：这种编码技巧最常用于会计系统的设计里，因为会计制度经常需要对很长的数字串作准确的计算。相对于一般的浮点式记数法，采用BCD码，即可保存数值的精确度，又可免去使计算机作浮点运算时所耗费的时间。此外，对于其他需要高精确度的计算，BCD编码亦很常用。</li></ul><h5 id="有权码和无权码："><a href="#有权码和无权码：" class="headerlink" title="有权码和无权码："></a>有权码和无权码：</h5><p><img src="/img/C-O/2.1.2.png"></p><h5 id="8421码的计算："><a href="#8421码的计算：" class="headerlink" title="8421码的计算："></a>8421码的计算：</h5><ul><li>当两个8421码进行计算时，如果结果小于等于0，则不作任何操作，如果计算结果大于9，则需要进行+6（0110）修正操作，并向高位进位。</li></ul><blockquote><p>计算5+8：</p><p>​8421 BCD替换： 0101+1000 &#x3D; 1101 </p><p>​此时大于9，需要加上6&#x3D;0110 —&gt;10011，此时1为高位，0011为低位，满足BCD：即13</p></blockquote><h4 id="2-1-4-什么是ASCII码？"><a href="#2-1-4-什么是ASCII码？" class="headerlink" title="2.1.4 什么是ASCII码？"></a>2.1.4 什么是ASCII码？</h4><ul><li>我们知道我们日常见到的数字（0-9）、符号比如：#、%、+、@等、英语字母如：(A-z)、(a~z),它们在计算机中都是以二进制来表示存储的，咱们可以用不同的二进制数来表示，但是为了统一化、使大家的相互通信可以正常进行，那么就必须制定一套统一的标准来规范它，由此ASCII码随之诞生，大家都遵从这一统一的标准进行数据的通信和交流。</li></ul><h4 id="2-1-5-校验码（略）"><a href="#2-1-5-校验码（略）" class="headerlink" title="2.1.5 校验码（略）"></a>2.1.5 校验码（略）</h4><h5 id="1-什么是校验码"><a href="#1-什么是校验码" class="headerlink" title="1.什么是校验码"></a>1.什么是校验码</h5><ul><li>校验码：指能够发现或能够自动纠正错误的数据编码，也称检错纠错编码</li><li>实现原理：通过加一冗余码，来检验或纠错编码</li><li>码距：简单来说就是两个二进制数比较，在同一数位的地方数值位不同的个数有多少个，即码距，也称海明距离。</li><li>两种方法计算码距：如0100和0111：<ul><li><code>直接观察法</code>：可以看出有3个数值位不同，码距为3</li><li><code>异或计算法</code>：0100⊕1111&#x3D;1011 ，结果为1011，里面有几个1就代表有多少个数位值不同，即码距是多少，这里码距是3。</li></ul></li></ul><h5 id="2-为什么要有校验码？"><a href="#2-为什么要有校验码？" class="headerlink" title="2.为什么要有校验码？"></a>2.为什么要有校验码？</h5><ul><li>其实从什么是校验码，就可以看出为什么要有校验码，在计算机的运算过程中，所有数据都是以二进制保存的，数据在计算机中进行运算处理传递的时候，我们要对数据进行加工，为什么要加工呢？是为了防止在传输过程中由于硬件等方面的因素导致数据发生变化，当我们加工数据增加冗余位后，原始数据码就变成了校验码，我们可以通过相对应的校验码的一些方法来检测和纠正错误，保证数据的准确性</li></ul><h3 id="2-2-定点数的表示和运算"><a href="#2-2-定点数的表示和运算" class="headerlink" title="2.2 定点数的表示和运算"></a>2.2 定点数的表示和运算</h3><h4 id="2-2-1-定点数的表示"><a href="#2-2-1-定点数的表示" class="headerlink" title="2.2.1 定点数的表示"></a>2.2.1 定点数的表示</h4><h5 id="1-有符号数和无符号数"><a href="#1-有符号数和无符号数" class="headerlink" title="1.有符号数和无符号数"></a>1.有符号数和无符号数</h5><ul><li><p>无符号数：指整个机器字长的全部二进制位均为数值位，没有符号位。若机器字长为8位，则数的表示范围 0<del>28-1 , 即0</del>255。</p></li><li><p>有符号数：在机器中，数的正负我们无法识别，但是我们可以用二进制数来代替正负号。一般‘0’为正，‘1’为负，符号位一般在有效数的最前面。若机器字长为8位，是有符号数，则数的表示范围为 -27<del>27-1 ，即-128</del>127。</p></li></ul><p><font color=red>注：讨论的原码等是建立在有符号数的前提上，也就是说最高位是符号位</font></p><h5 id="2-机器数的定点表示"><a href="#2-机器数的定点表示" class="headerlink" title="2.机器数的定点表示"></a>2.机器数的定点表示</h5><ul><li>根据小数点的位置是否固定，在计算机中，有两种数据格式：定点和浮点表示</li><li>定点表示即约定机器数中小数点位置是固定不变的，小数点不再用“.”表示，而是约定它的位置</li><li>定点小数：一般将小数点的位置固定在数据的<code>最高位之前</code></li><li>定点整数：一般将小数点的位置固定在数据的<code>最高位之后</code></li></ul><h5 id="3-原码、补码、反码、移码"><a href="#3-原码、补码、反码、移码" class="headerlink" title="3.原码、补码、反码、移码"></a>3.原码、补码、反码、移码</h5><p><strong>原码</strong>：符号位“0”表示正数，“1”表示负数，数值位即真值的绝对值</p><p><strong>反码</strong>：通常用来作为原码求补码，或补码求原码的中间过渡、正数反码就是正数</p><p><strong>补码</strong>：可以将减法操作化作加法操作。正数的补码是其本身, 负数的补码可以看作对其原码<strong>除符号位外, 每位求反, 末位加1。特别地, [x]补 经过符号位和数值位按位取反+1 得到[-x]补。</strong></p><p><strong>移码</strong>：针对补码无法直接比较大小而引出的一种表示法，即对补码加上一个$$2^n$$，即将最高位符号位取反</p><p><strong>除0</strong>：故障</p><p><strong>长字节转短字节</strong>：截断高位</p><p><strong>短字节转长字节</strong>：符号扩展</p><blockquote><p>备注: </p><ol><li>十进制小数不一定都能用二进制表示。</li><li>原码, 反码的表示在数轴上对称, 存在+0和-0；而补码, 移码的0是唯一的。</li><li>移码和补码的符号位相反, 数值位相同</li><li>负数的补码中, 数值部分越大, 真值越大(更靠近0), 多表示一个最小负数</li><li>移码保持数据原有大小顺序, 移码大则真值大</li><li>补码符号位可以参与运算</li></ol></blockquote><ul><li>移码越大真值越大，移码越小真值越小</li><li>[+0]原 &#x3D; 0000 , [-0]原 &#x3D; 1000<br>  [+0]补 &#x3D; [-0]补 &#x3D; 0.000<br>  [+0]反 &#x3D; 0.000 , [-0]反 &#x3D; 1.111</li></ul><p><img src="/img/C-O/2.2.1.jpg"></p><h4 id="2-2-2-定点数的运算"><a href="#2-2-2-定点数的运算" class="headerlink" title="2.2.2 定点数的运算"></a>2.2.2 定点数的运算</h4><h5 id="1-定点数移位运算"><a href="#1-定点数移位运算" class="headerlink" title="1.定点数移位运算"></a>1.定点数移位运算</h5><ul><li>移位运算：根据操作对象不同分为算术移位和逻辑移位</li><li>算术移位：有符号数的移位</li><li>逻辑移位：操作对象是逻辑代码，可视为无符号数</li></ul><p>（1）算术移位</p><ul><li>算术移位规则（未溢出，未移出）</li></ul><p><img src="/img/C-O/2.2.2.png"></p><p>（2）逻辑移位</p><ul><li>移位规则：左移右移都是填0</li></ul><h5 id="2-定点数加减法运算"><a href="#2-定点数加减法运算" class="headerlink" title="2.定点数加减法运算"></a>2.定点数加减法运算</h5><p>（1）原码加减</p><ul><li>加法：绝对值相加，符号位不变</li><li>减法：绝对值大的减绝对值小的数，结果的符号和绝对值大的数相同</li><li>这里的加法运算，其实当两个数符号位不同时就按减法规则算</li><li>注意：运算时超出字长，则左边溢出位丢掉</li></ul><p>（2）补码加减</p><p>为什么机器中使用补码运算规则？</p><ul><li>补码统一了符号位和数值位，加法和减法也可以统一处理，只需要加法器，不需要减法器，节省元件，简化了运算器的设计，提高效率</li><li>注意：符号位与数值位一起运算，符号位产生的进位丢掉，结果的符号位数值由运算得出</li></ul><p><img src="/img/C-O/2.2.3.jpg"></p><h5 id="3-符号扩展"><a href="#3-符号扩展" class="headerlink" title="3.符号扩展"></a>3.符号扩展</h5><ul><li>符号扩展：有时需要把两种不同位数的数相加，那么需要统一他们的位数，比如8位和16位数相加，要想得到正确的结果，必须把8位数转换成16位数</li></ul><p>（1）正数符号扩展</p><ul><li>原码&#x3D;补码&#x3D;反码：比如8位转16位：+12(10) &#x3D; 0000 1100 , 转换成16位则为：0000 0000 0000 1100</li><li>符号位为0，附加为都用0补充</li></ul><p>（2）负数符号扩展</p><p>比如8位转16位：-12 (10) &#x3D; 1000 1100</p><ul><li>原码：扩展方法与正数符号扩展相同，只不过最高位符号位变为1, 1000 0000 0000 1100</li><li>补码：附加位补充1，符号位为1，1111 1111 1111 1100</li><li>反码：附加位补充1，符号位为1，1111 1111 1111 1100</li></ul><h5 id="4-溢出概念和判别方法"><a href="#4-溢出概念和判别方法" class="headerlink" title="4.溢出概念和判别方法"></a>4.溢出概念和判别方法</h5><ul><li>溢出：指参加运算的两个数，相加或相减，运算结果超过了机器字长所能表示的范围</li><li>正溢出：运算结果大于机器字长所能表示的最大正数</li><li>负溢出：运算结果小于机器字长所能表示的最小负数</li></ul><h5 id="5-定点数乘法运算"><a href="#5-定点数乘法运算" class="headerlink" title="5.定点数乘法运算"></a>5.定点数乘法运算</h5><p>（1）原码一位乘法</p><ul><li>运算细则：</li></ul><ol><li>被乘数和乘数均取绝对值参加运算，符号位异或运算；</li><li>部分积的长度和被乘数一样，取n+1位，初值为0；</li><li>从乘数的最低位yn开始判断；若yn&#x3D;1，则高位部分积加上被乘数|x| , 高位部分积然后右移一位；若yn&#x3D;0，则高位部分积加上0，高位部分积右移一位；</li><li>重复2步骤，判断n次</li></ol><p><font color =red>符号位异或操作，同为0假，异为1真。其余进行绝对值求积</font></p><p>（2）补码一位乘法（Booth算法）<strong>（略）</strong></p><ul><li>一种有符号的乘法，采取相加和相减操作计算补码数据的乘积。</li><li>运算规则：</li></ul><ol><li>符号位参与运算，运算的数均以补码表示</li><li>被乘数一般取双符号位参与运算，部分积取双符号位，初值为0，乘数可取单符号位</li><li>乘数末位增设附加位yn+1，初值为0</li><li>根据（yn,yn+1）的取值来确定操作，见下表规则</li><li>有符号数，移位按补码右移算术移位规则进行，右移补充1，左移补充0</li><li>按上诉步骤进行n+1次步骤，第n+1次不移位。累加n+1次，移位n次</li></ol><h5 id="6-定点数除法运算"><a href="#6-定点数除法运算" class="headerlink" title="6.定点数除法运算"></a>6.定点数除法运算</h5><ul><li>在计算机中，除法运算可转换成<code>累加+左移（逻辑左移）</code></li></ul><p>（1）原码除法运算（不恢复余数法）</p><ul><li>采用方法：原码不恢复余数法，也称原码加减交替除法，符号位和数值单独处理</li></ul><p><img src="/img/C-O/2.2.4.jpg"></p><h3 id="2-3-浮点数的表示和运算"><a href="#2-3-浮点数的表示和运算" class="headerlink" title="2.3 浮点数的表示和运算"></a>2.3 浮点数的表示和运算</h3><p><img src="/img/C-O/2.2.3.png"></p><h4 id="1-基本格式"><a href="#1-基本格式" class="headerlink" title="1.基本格式"></a>1.基本格式</h4><p><img src="/img/C-O/2.3.1.png"></p><p>例子：</p><p><img src="/img/C-O/2.3.2.png"></p><h4 id="2-规格化"><a href="#2-规格化" class="headerlink" title="2.规格化"></a>2.规格化</h4><p><img src="/img/C-O/2.3.3.png"></p><h4 id="3-IEEE-754标准"><a href="#3-IEEE-754标准" class="headerlink" title="3.IEEE 754标准"></a>3.IEEE 754标准</h4><p><img src="/img/C-O/2.3.4.png"></p><h4 id="4-浮点数加减运算："><a href="#4-浮点数加减运算：" class="headerlink" title="4.浮点数加减运算："></a>4.浮点数加减运算：</h4><p>浮点数加减运算步骤：</p><ol><li>对阶</li><li>尾数加减</li><li>规格化</li><li>舍入</li><li>判溢出</li></ol><p>例子：</p><p><img src="/img/C-O/2.3.5.png"></p><h3 id="2-4-算术逻辑单元ALU与加法器-略"><a href="#2-4-算术逻辑单元ALU与加法器-略" class="headerlink" title="2.4 算术逻辑单元ALU与加法器(略)"></a>2.4 算术逻辑单元ALU与加法器(略)</h3><p><img src="/img/C-O/2.3.6.png"></p><h2 id="第三章-存储系统"><a href="#第三章-存储系统" class="headerlink" title="第三章 存储系统"></a>第三章 存储系统</h2><h2 id="第四章-指令系统"><a href="#第四章-指令系统" class="headerlink" title="第四章 指令系统"></a>第四章 指令系统</h2><h2 id="第五章-中央处理器"><a href="#第五章-中央处理器" class="headerlink" title="第五章 中央处理器"></a>第五章 中央处理器</h2><h2 id="第六章-总线"><a href="#第六章-总线" class="headerlink" title="第六章 总线"></a>第六章 总线</h2><h3 id="2-1-总线概念及性能指标"><a href="#2-1-总线概念及性能指标" class="headerlink" title="2.1 总线概念及性能指标"></a>2.1 总线概念及性能指标</h3><p><strong>传送周期（总线周期）</strong>：一次总线操作所需时间，包含申请阶段，寻址阶段，传输阶段等</p><p><strong>总线的时钟周期</strong>：即机器时钟周期</p><p><strong>总线的工作频率</strong>：总线周期的倒数</p><p><strong>总线的时钟频率</strong>：时钟周期的倒数</p><p><strong>总线宽度</strong>：数据总线的根数</p><p><strong>总线带宽</strong>：总线宽度 * 总线工作频率</p><p><strong>主设备</strong>：发出总线请求且获得总线控制权的设备</p><p><strong>从设备</strong>：指被主设备访问的设备</p><p><strong>片内总线</strong>：CPU内部各寄存器之间及ALU的连接</p><p><strong>系统总线：</strong></p><ul><li>数据总线：双向传输总线，位数与机器字长、存储字长有关</li><li>地址总线：指明CPU访问的存储单元或I&#x2F;O端口的地址，单项传输，位数与存储单元有关</li><li>控制总线：用来发出各种控制信号的传输线，单向传输</li><li>猝发传送：传输一次首地址和一组数据</li><li>I&#x2F;O总线与通信总线：CPU和主存通过I&#x2F;O总线与主机相连，I&#x2F;O接口通过通信总线（电缆）与外设相连</li></ul><h5 id="1-总线的定义"><a href="#1-总线的定义" class="headerlink" title="1.总线的定义"></a>1.总线的定义</h5><p>总线是一组能为多个部件<strong>分时共享</strong>的公共信息传送线路。</p><h5 id="2-为什么要用总线？"><a href="#2-为什么要用总线？" class="headerlink" title="2.为什么要用总线？"></a>2.为什么要用总线？</h5><p>早期计算机外部设备少时大家采用分散连接方式，不易实现随时增减外部设备，为了更好地解决I&#x2F;O设备和主机之间连接的灵活性问题，计算机的结构从分散链接发展为总线连接。</p><h5 id="3-总线的特性"><a href="#3-总线的特性" class="headerlink" title="3.总线的特性"></a>3.总线的特性</h5><blockquote><p>机械特性：尺寸、形状、管脚数、排列顺序</p><p>电气特性：传输方向和有效的电平范围</p><p>功能特性：每根传输线的功能（地址，数据，控制）</p><p>时间特性：信号的时序关系</p></blockquote><h2 id="第七章-输入-输出系统"><a href="#第七章-输入-输出系统" class="headerlink" title="第七章 输入&#x2F;输出系统"></a>第七章 输入&#x2F;输出系统</h2>]]></content>
    
    
    
    <tags>
      
      <tag>408</tag>
      
      <tag>Computer Organization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/Linux/"/>
    <url>/Linux/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AndroidApp</title>
    <link href="/AndroidApp/"/>
    <url>/AndroidApp/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-应用开发模式"><a href="#Android-应用开发模式" class="headerlink" title="Android 应用开发模式"></a>Android 应用开发模式</h1><div class="note note-primary">            <p>本内容结合博主自己开发Android App的经历，在这中间遇到很多的波折，将这些整理下来并且给予初学者一个帮助，本文将通过最简单的方式带你入门，并且独自开发一个app。</p>          </div><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>参考资料：《Android Sudio开发实践——从零基础到App上线》欧阳燊<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>参考内容：……<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>软件开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>System Operation</title>
    <link href="/System/"/>
    <url>/System/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-操作系统概述"><a href="#第一章-操作系统概述" class="headerlink" title="第一章 操作系统概述"></a>第一章 操作系统概述</h1><div class="note note-primary">            <p>本文主要针对408考研内容编写，以及Linux等操作。</p>          </div><h2 id="1-1-操作系统简介"><a href="#1-1-操作系统简介" class="headerlink" title="1.1 操作系统简介"></a>1.1 操作系统简介</h2><p><code>操作系统能做什么？</code></p><div class="note note-warning">            <ul><li>从用户的角度：<ol><li>提供良好的用户界面</li><li>标准的函数库</li><li>使得编程更加方便并且不容易出错</li></ol></li><li>从系统的角度：<ol><li>管理资源（硬件资源、处理机、存储器、设备；信息资源【文件】）</li><li>解决申请资源时产生的冲突</li><li>阻止错误的产生和计算机不正当的使用</li></ol></li></ul>          </div><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p><font color="red">操作系统（Operation System，OS）</font>：是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本你爹系统软件。</p><blockquote><ul><li><p>An operating system acts an intermediary between user of a computer and the computer</p><p>  hardware.</p><ul><li>操作系统充当计算机⽤⼾和计算机硬件之间的中介</li></ul></li><li><p>The purpose of an operating system is to provide an environment in which a user can execute</p><p>  programs in a convenient and efficient manner.</p><ul><li>操作系统的⽬的是提供⼀个⽤⼾可以⽅便和有效地执⾏程序的环境</li></ul></li><li><p>An operating system is software that manages the computer hardware.</p><ul><li>操作系统是管理计算机硬件的软件</li></ul></li></ul></blockquote><p><img src="/img/System/1.1.png" alt="现代计算机硬件结构"></p><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><div class="note note-success">            <p>这里的内容以及和下面的<strong>存储器</strong>，<strong>I&#x2F;O设备</strong>，<strong>总线</strong>等都是计算机组成原理中的重要内容，在本文中也是按照书中给的内容进行叙述。下面有链接可以查看具体的讲解。（部分内容已经脱离408考点，主要是知识扩展）</p>          </div><blockquote><p>处理器（中央处理器（Central Processing Unit）—— CPU）：</p><ul><li><p>CPU工作的基本周期是：提取指令，译码分析，执行指令。（接化发！<code>链接中有讲到</code>）</p></li><li><p>CPU内部包含若干寄存器</p><ul><li><p>通用寄存器：</p><p>  ​用来存放关键变量和中间结果。</p></li><li><p>专用寄存器：</p><ul><li><p>程序计数器（PC）：</p><p>  ​PC中保存下面要提取指令的内存地址。</p></li><li><p>栈指针寄存器：</p><p>  ​存放指向当前内存栈的顶端的指针；该栈中保存有关函数（过程）调用时的现场信息，包括输入参数、局部变量和未在寄存器中保存的临时变量。</p><p>  ​程序执行过程中调用的每个函数在栈中站有一个帧面。</p></li><li><p>程序状态字（PSW）：</p><p>  ​条件码位、CPU优先级、程序执行模式（<strong>用户态</strong>或者<strong>核心态</strong>）和各种其他控制位。</p><p>  ​在系统调用和I&#x2F;O中PSW起重要作用。</p></li></ul></li></ul></li><li><p>处理机执行状态——保护操作系统程序，防止收到用户程序的损害：</p><ul><li><p>用户态</p><p>  ​用户程序（各种应用程序、工具、例程等）在用户态下执行，它们权限较低，只能执行指令集中非特权指令。</p></li><li><p>核心态（系统态、管理态）</p><p>  ​处于核心态，有较高特权，可以执行所有指令，包括普通用户程序中不能使用的<strong>特权指令</strong>，从而能对<strong>所有寄存器</strong>和<strong>内存</strong>进行访问，以及<strong>启动I&#x2F;O操作</strong>等。</p></li></ul></li></ul><p></p></blockquote><p><a href="https://polaris516.github.io/CO_CPU">中央处理器——CPU</a></p><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><blockquote><p>存储器（memory）：按照速度、容量和成本划分，存储器系统构成一个层次结构。（如图1.2）</p><ul><li><p>顶层是CPU的内部寄存器，速度和CPU一样快，存取它们没有延迟。但成本高，容量小，通常小于1KB</p></li><li><p>高速缓存：</p><p>  ​当程序需要读取具体信息时，Cache硬件先查看它是否在Cache中，如果在其中（“命中”），就直接使用它；反之，就从内存中获取该信息，并把它放入Cache中。小于4MB</p></li><li><p>内存（主存）：</p><ul><li>存储器系统的主力，也称作RAM（随机存取存储器）</li><li>CPU可以直接存取内存及寄存器和Cache中的信息。</li><li>机器执行的指令及所用的数据必须先存放在内存及Cache和寄存器中。</li><li>内存中存放的信息是易失的，当机器电源被关闭后，内存中的信息就全部丢失了。</li></ul></li><li><p>磁盘（硬盘、辅助存储器或者辅存、外存）：</p><ul><li>对内存的扩展</li><li>磁盘上可以永久保留数据，容量特别大</li><li>磁盘上数据的存取速度低于内存存取速度</li></ul></li><li><p>磁带</p><ul><li>数据永久保存，容量很大，存取速度很慢，不适宜随机存取。</li><li>主要作为文件系统的后备，存放不常用的信息或用做系统间的传送信息的介质。</li></ul></li><li><p>其他存储器：如软盘，光盘（CD-ROM）、U盘等</p></li></ul></blockquote><p><img src="/img/System/1.2.1.png" alt="图1.2"></p><p><a href="https://polaris516.github.io/CO_Memory">存储器——Memory</a></p><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h3><blockquote><ul><li><p>控制器：</p><p>  ​控制器是I&#x2F;O设备的电子部分，它协调和控制一台或多台I&#x2F;O设备的操作，实现设备操作与整个系统操作的同步。</p></li><li><p>设备:</p><p>  ​本身的对外接口相当简单，实际上他们隐藏在控制器后面</p></li></ul><p>设备驱动程序：向控制器发布命令并接收其回答信息的软件。</p></blockquote><ul><li>存储器只是众多IO设备的一种，IO设备是计算机体系结构中种类最丰富的设备类型，而且它有着很强的扩展性</li><li>管理IO设备是操作系统非常重要的组成成分，操作系统中有一个专门的IO子系统负责完成这项工作。</li></ul><p><a href="https://polaris516.github.io/CO_I-O">I&#x2F;O设备</a></p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><blockquote><ul><li><p>数据总线：</p><p>  ​计算机各部件之间传送数据的通道，其宽度随字长而定</p><p>  ​数据总线是双向总线，即两个方向都能传送数据</p></li><li><p>地址总线：</p><p>  ​从CPU送来地址的地址线，它可以是存储器的地址，也可以是IO设备控制器中中控制寄存器或数据寄存器的地址</p></li><li><p>控制总线：</p><p>  ​在该线上出现的信号是各个模块之间传送数据时所需的全部控制信号</p></li></ul></blockquote><h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><p><img src="/img/System/1.2.2.png"></p><h4 id="1-并发："><a href="#1-并发：" class="headerlink" title="1.并发："></a>1.并发：</h4><p><code>并发</code>：两个或多个事件在同一个时间间隔内发生，这些事件在宏观上是同时发生的，在微观上是交替发生的，操作系统的并发性指系统中同时存在着多个运行的程序</p><p><code>并行</code>：两个或多个事件在同一个时刻发生</p><p>一个单核（CPU）同一时刻只能执行一个程序，因此操作系统会协调多个程序使他们交替进行（这些程序在宏观上是同时发生的，在微观上是交替进行的）</p><p>操作系统是伴随着“多道程序技术出现的”，因此操作系统和并发是一同诞生的</p><p>在如今的计算机中，一般都是多核CPU的，即在同一时刻可以并行执行多个程序。</p><h4 id="2-共享："><a href="#2-共享：" class="headerlink" title="2.共享："></a>2.共享：</h4><ul><li>资源共享即共享，是指系统中的资源可以<code>供内存中多个并发执行的进程</code>共同使用</li><li>共享分为两类：互斥共享和同时共享<ol><li>互斥共享<ul><li>计算机中的某个资源在一段时间内只能允许一个进程访问，别的进程没有使用权</li><li>临界资源（独占资源）：在一段时间内只允许一个进程访问，别的进程没有使用权</li><li>eg：QQ和微信视频，同一段时间内摄像头只能分配给其中一个进程</li></ul></li><li>同时共享<ul><li>计算机中的某个资源在一段时间内可以同时允许多个进程访问</li><li>同时共享通常要求一个请求分为几个时间片段间隔的完成，即交替进行，“分时共享”</li><li>这里的同时指在宏观上是同时的，在微观上是交替进行访问的，只是CPU处理速度很快，我们感觉不到。在宏观上感觉是在同时进行</li><li>eg：比如QQ在发送文件A，微信在发送文件B，宏观上两个进程A和B都在访问磁盘，在我们看来是同时进行的，但是在微观上两个进程A和B是交替进行的，只是时间太短，cpu处理速度太快，我们感觉不到。</li><li><code>注意</code>：有时候多个进程可能真的是在同时进行资源访问，比如玩游戏时可以放音乐，游戏声音和音乐声音都能听见</li></ul></li></ol></li></ul><h4 id="3-并发和共享的关系"><a href="#3-并发和共享的关系" class="headerlink" title="3.并发和共享的关系"></a>3.并发和共享的关系</h4><p>并发性指计算机系统中同时存在着多个运行着的程序</p><p>共享性是指系统中的资源可供内存中多个并发执行的进程共同使用</p><ul><li>从上述例子来看二者之间的关系：<ol><li>两个进程正在并发执行（并发性）</li><li>需要共享地访问硬盘资源（共享性）</li></ol></li></ul><p><code>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义</code></p><p><code>如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发</code></p><h4 id="4-虚拟"><a href="#4-虚拟" class="headerlink" title="4.虚拟"></a>4.虚拟</h4><blockquote><p>多道程序设计：是指在计算机内存中同时存放几道互相独立的程序，使它们在管理程序控制之下，相互穿插的运行。两个或两个以上的程序在计算机系统中同处于开始到结束之间的状态。这就称为多道程序设计。多道程序技术运行的特征：多道、宏观上并行、微观上串行。</p></blockquote><ul><li>虚拟是把一个物理上的实体变为若干逻辑上的对应物</li><li>物理实体（前者）是实际存在的；而后者是虚的，是用户感觉上的事务</li><li>虚拟技术：用于实现虚拟的技术</li><li>虚拟处理器（CPU）：通过多道程序设计技术，采用让多道程序并发执行的方法，分时来使用一个CPU，实际物理上只有一个CPU，但是用户感觉到有多个CPU</li><li>虚拟存储器：从逻辑上扩充存储器容量，用户感觉到的但实际不存在的存储器</li><li>虚拟设备：将一台物理设备虚拟为逻辑上的多台设备，使多个用户在同一时间段内访问同一台设备，即同时共享，用户宏观上感觉是同时的，但实际上是微观交替访问同一台设备</li><li>操作系统的虚拟技术可归纳为：<ul><li>时分复用技术：如处理器的分时共享</li><li>空间复用技术：如虚拟处理器</li></ul></li></ul><p><code>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此没有并发性，就谈不上虚拟性</code></p><h4 id="5-异步"><a href="#5-异步" class="headerlink" title="5.异步"></a>5.异步</h4><ul><li>异步：多道程序环境允许多个程序并发执行，但由于资源有限，如cpu只有一个，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进。</li><li>比如A进程正在占用CPU计算，B进程这时也想占用CPU计算，B进程只有等，等A进程算完了，A进程去访问磁盘资源了，这时B进程再占用CPU进行计算，B进程还没计算完，A进程从磁盘取出资源了，A进程发现B这时在占用CPU，这时A进程就需要等待，等B算完后再继续到CPU中进行计算。由于每个进程占用资源的时间不固定，所以进程的执行以不可预知的速度前进</li></ul><h2 id="1-2-处理器系统"><a href="#1-2-处理器系统" class="headerlink" title="1.2 处理器系统"></a>1.2 处理器系统</h2><p><img src="/img/System/1.3.1.png"></p><h3 id="单处理器系统"><a href="#单处理器系统" class="headerlink" title="单处理器系统"></a>单处理器系统</h3><ul><li>Single-progress System</li><li>只有一颗注CPU，执行通用指令集</li><li>带有其他专用处理器，为特定设备服务，如：磁盘、键盘、图形控制器等<ul><li>它们能够执行的指令有限，不处理用户进程</li><li>操作系统会向它们发出任务，并监控它们的状态</li></ul></li></ul><h3 id="多处理器系统"><a href="#多处理器系统" class="headerlink" title="多处理器系统"></a>多处理器系统</h3><ul><li>Multi processor&#x2F;Muliticore System</li><li>有两个或多个紧密通信的CPU，它们共享计算机总线、时钟、内存和外设等。</li></ul><h3 id="集群系统"><a href="#集群系统" class="headerlink" title="集群系统"></a>集群系统</h3><ul><li>Clustered System</li><li>该系统由若干节点（Node）通过网络连接在一起，每个节点可为单处理器系统或多处理器系统，节点之间是松耦合（loosely coupled)关系<ul><li>高可用性（high availability）</li><li>高性能计算（high-performance computing)</li></ul></li></ul><h3 id="单道单用户模式"><a href="#单道单用户模式" class="headerlink" title="单道单用户模式"></a>单道单用户模式</h3><p><img src="/img/System/1.3.png" alt="单道单用户模式"></p><h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><ul><li>操作系统最重要的一点是具有多道程序的能力</li><li>单道程序不能让CPU和IO设备始终忙碌，多道程序设计通过安排任务使用的CPU总有一个执行任务，从而提高CPU利用率</li><li>实现的硬件保证：处理器和IO设备具有并行工作的能力</li></ul><h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><ul><li>分时系统也称多任务系统，是多道程序设计的自然延伸</li><li>允许多个用户共享一台计算机<ul><li>用户只有输入和输出设备</li><li>分时系统为每个用户轮流分配等量的CPU时间</li><li>用户从发出指令得到得到即时结果的时间称为响应时间</li></ul></li><li>第一个分时系统CTSS由MIT于1962年开发出来</li></ul><h2 id="1-3-操作系统的发展历程："><a href="#1-3-操作系统的发展历程：" class="headerlink" title="1.3 操作系统的发展历程："></a>1.3 操作系统的发展历程：</h2><p><img src="/img/System/1.3.2.png"></p><h2 id="1-4-操作系统的运行机制和体系结构"><a href="#1-4-操作系统的运行机制和体系结构" class="headerlink" title="1.4 操作系统的运行机制和体系结构"></a>1.4 操作系统的运行机制和体系结构</h2><h3 id="1-4-1-操作系统的运行机制和体系结构"><a href="#1-4-1-操作系统的运行机制和体系结构" class="headerlink" title="1.4.1 操作系统的运行机制和体系结构"></a>1.4.1 操作系统的运行机制和体系结构</h3><h4 id="1-操作系统的运行机制和体系结构"><a href="#1-操作系统的运行机制和体系结构" class="headerlink" title="1.操作系统的运行机制和体系结构"></a>1.操作系统的运行机制和体系结构</h4><p><img src="/img/System/1.5.1.png"></p><h4 id="2-操作系统体系结构类比"><a href="#2-操作系统体系结构类比" class="headerlink" title="2.操作系统体系结构类比"></a>2.操作系统体系结构类比</h4><p>类比：</p><p>操作系统体系结构问题与企业的管理问题很相似。</p><p>内核就是企业的管理层，负责一些重要的工作。只有管理层才能执行特权指令，普通员工只能执行非特权指令。用户态，核心态之间的切换相当于普通员工和管理层之间的工作交接</p><p>大内核：企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高；缺点是组织结构混乱，难以维护</p><p>微内核：随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护；缺点是效率低</p><h4 id="3-操作系统用户态和核心态的转换"><a href="#3-操作系统用户态和核心态的转换" class="headerlink" title="3.操作系统用户态和核心态的转换"></a>3.操作系统用户态和核心态的转换</h4><p>“用户态 -&gt; 核心态”是通过中断实现的。并且中断是唯一途径。“核心态 -&gt; 用户态”的切换是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”</p><h3 id="1-4-2-中断和异常"><a href="#1-4-2-中断和异常" class="headerlink" title="1.4.2 中断和异常"></a>1.4.2 中断和异常</h3><p><img src="/img/System/1.5.2.png"></p><p> 中断</p><ul><li>当有事件（event）发生时，CPU会收到一个中断（interrupt）信号，可以是硬中断也可以是软中断</li><li>CPU会停下正在做的事，转而执行中断处理程序，执行完毕会回到之前被中断的地方继续执行</li><li>Operation System is an Interrupt driven system<ul><li>操作系统是一个由中断驱动的系统</li></ul></li></ul><h3 id="1-4-3-系统调用（执行过程、访管指令、库函数与系统调用）"><a href="#1-4-3-系统调用（执行过程、访管指令、库函数与系统调用）" class="headerlink" title="1.4.3 系统调用（执行过程、访管指令、库函数与系统调用）"></a>1.4.3 系统调用（执行过程、访管指令、库函数与系统调用）</h3><p><img src="/img/System/1.4.3.png"></p><h1 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h1><h2 id="2-1-进程与线程"><a href="#2-1-进程与线程" class="headerlink" title="2.1 进程与线程"></a>2.1 进程与线程</h2><h3 id="2-1-1-进程的定义、特征、组成、组织"><a href="#2-1-1-进程的定义、特征、组成、组织" class="headerlink" title="2.1.1 进程的定义、特征、组成、组织"></a>2.1.1 进程的定义、特征、组成、组织</h3><h4 id="1-进程的定义"><a href="#1-进程的定义" class="headerlink" title="1.进程的定义"></a>1.进程的定义</h4><h5 id="1-程序的概念"><a href="#1-程序的概念" class="headerlink" title="1.程序的概念"></a>1.程序的概念</h5><p>程序：就是一个指令序列</p><h5 id="2-进程的概念（引入多道程序技术之后）"><a href="#2-进程的概念（引入多道程序技术之后）" class="headerlink" title="2.进程的概念（引入多道程序技术之后）"></a>2.进程的概念（引入多道程序技术之后）</h5><ul><li>为了方便操作系统管理，完成各程序并发执行，引入了进程，进程实体的概念</li><li>PCB、程序段、数据段三部分构成了进程实体（进程映像）</li></ul><blockquote><p><font color =orange>进程和程序的区别与联系：</font></p><ol><li><p>进程是动态的，程序是静态的</p></li><li><p>进程有独立性，能并发执行，程序不能并发执行</p></li><li><p>二者无一一对应关系</p></li><li><p>进程异步运行，会相互制约；程序不具备此特征</p><p> 但是，进程和程序又有密切的联系：进程不能脱离具体程序而虚设，程序规定了相应进程所要完成的动作。</p></li><li><p>组成不同：进程包含PCB、程序段、数据段。程序包含数据和指令代码。</p></li><li><p>程序是一个包含了所有指令和数据的静态实体。本身除占用磁盘的存储空间外，并不占用系统如CPU、内存等运行资源。</p></li><li><p>进程由程序段、数据段和PCB构成，会占用系统CPU、内存等运行资源。</p></li><li><p>一个程序可以启动多个进程来共同完成</p></li></ol><p><font color=red>联系：进程不能脱离具体程序而虚设，程序规定了相应进程所要完成的动作。</font></p></blockquote><h5 id="3-进程的定义"><a href="#3-进程的定义" class="headerlink" title="3.进程的定义"></a>3.进程的定义</h5><p>程序段、数据段、PCB三部分组成了进程实体（进程映像）。一般情况下，我们把进程实体就简称为<strong>进程</strong>，例如，所谓创建进程，实质上是创建进程实体中的PCB，而撤销进程，实质上是撤销进程实体中的PCB。</p><p><font color=blue>PCB是进程存在的唯一标志</font></p><p>从不同角度，进程可以有不同的定义，比较传统典型的定义有：</p><ol><li>进程是程序的一次执行过程</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li><li>进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li></ol><p>引入进程实体的概念后，可以把进程定义为：</p><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p><p><font color=red>严格来说，进程和进程实体并不一样，进程实体是静态的，进程则是动态的。不过，除非题目专门考察二者的区别，否则可以认为进程实体就是进程，因此我们也可以说进程实体是由程序段、数据段、PCB三部分组成的。</font></p><h4 id="2-进程的特征"><a href="#2-进程的特征" class="headerlink" title="2.进程的特征"></a>2.进程的特征</h4><p><img src="/img/System/2.1.png"></p><h4 id="3-进程的组成"><a href="#3-进程的组成" class="headerlink" title="3.进程的组成"></a>3.进程的组成</h4><p><strong>PCB（Process Control Block）进程控制块：</strong></p><ul><li><p>PCB中记录了操作系统所需的，用于描述进程的当前情况以及控制进程运行的全部信息。</p><p>  ​PCB的作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位，一个能与其他进程并发运行的进程。</p><p>  ​或者说：<font color=purple>OS是根据PCB对并发执行的进程进行控制和管理的</font></p><p>  ​例如，当OS要<code>调度</code>某进程执行时，要从该进程的PCB中查处其现行状态及优先级；在调度某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据；</p><p>  ​进程在执行过程中，当需要和与之合作的进程实现同步，通信或者访问文件时，也都需要访问PCB；</p><p>  当进程由于某种原因而暂停执行时，又须将器断点的处理机环境保存在PCB中</p><p>  ​可见，在进程的整个生命期中，系统总是通过PCB对进程进行控制的，即系统是根据进程的PCB而不是任何别的什么而感知到该进程的存在的。</p><p>  ​所以说，PCB是进程存在的唯一标志。</p></li></ul><p><img src="/img/System/2.2.png"></p><h4 id="4-进程的组织"><a href="#4-进程的组织" class="headerlink" title="4.进程的组织"></a>4.进程的组织</h4><p>在一个系统中，通常有数十，数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。</p><p><font color = green>进程的组成讨论是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题</font></p><p><img src="/img/System/2.3.png"></p><h3 id="2-1-2-进程的状态及转换"><a href="#2-1-2-进程的状态及转换" class="headerlink" title="2.1.2 进程的状态及转换"></a>2.1.2 进程的状态及转换</h3><p><img src="/img/System/2.4.png"></p><h4 id="1-进程的状态"><a href="#1-进程的状态" class="headerlink" title="1.进程的状态"></a>1.进程的状态</h4><ol><li><p>三种基本状态（就绪、运行、阻塞）</p><p> 进程是程序的一次执行，在这个执行过程中，有时进程被CPU处理，有时又需要等待CPU服务，可见，进程的状态是会有各种变化，为了方便对各个进程的管理，操作系统需要将进程合理地划分为几个状态</p><p> <img src="/img/System/2.5.png"></p></li><li><p>创建态和结束态</p><p> <img src="/img/System/2.6.png"></p></li></ol><h4 id="2-进程状态之间的切换"><a href="#2-进程状态之间的切换" class="headerlink" title="2.进程状态之间的切换"></a>2.进程状态之间的切换</h4><p>进程一共5种状态：运行态，就绪态，阻塞态，创建态，终止态，他们之间如何实现切换？</p><p><img src="/img/System/2.7.png"></p><h3 id="2-1-3-原语实现对进程的控制"><a href="#2-1-3-原语实现对进程的控制" class="headerlink" title="2.1.3 原语实现对进程的控制"></a>2.1.3 原语实现对进程的控制</h3><p><img src="/img/System/2.8.png"></p><h4 id="1-什么是进程控制？"><a href="#1-什么是进程控制？" class="headerlink" title="1.什么是进程控制？"></a>1.什么是进程控制？</h4><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能（<strong>进程控制就是要实现进程状态转换</strong>）</p><h4 id="2-原语实现对进程的控制"><a href="#2-原语实现对进程的控制" class="headerlink" title="2.原语实现对进程的控制"></a>2.原语实现对进程的控制</h4><p><img src="/img/System/2.8.1.png"></p><p>用原语实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成</p><p>这种不能被中断的操作即原子操作。</p><p>原语采用“关中断指令”和“开中断指令”实现</p><h4 id="3-回忆进程组织"><a href="#3-回忆进程组织" class="headerlink" title="3.回忆进程组织"></a>3.回忆进程组织</h4><ul><li>进程在操作系统中的组织使各个进程能够有序的进行切换和运行</li></ul><h4 id="4-进程控制"><a href="#4-进程控制" class="headerlink" title="4.进程控制"></a>4.进程控制</h4><p><code>调度</code>：指决定资源分配给哪个进程的行为，是一种决策行为</p><p><code>切换</code>：指实际分配的行为，是执行行为</p><p>一般来说先有资源调度，后有进程切换</p><h4 id="5-进程控制原语的相同点"><a href="#5-进程控制原语的相同点" class="headerlink" title="5.进程控制原语的相同点"></a>5.进程控制原语的相同点</h4><p>进程控制会导致进程状态的转换。无论是哪个原语，要做的无非三件事情：</p><ol><li>更新PCB中的信息（如修改进程状态标志，将运行环境保存到PCB、从PCB恢复运行环境）<ul><li>所有的进程控制原语一定都会修改进程状态标志</li><li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li><li>某进程开始运行前必然要恢复其运行环境</li></ul></li><li>将PCB插入合适的队列</li><li>分配&#x2F;回收资源</li></ol><h4 id="6-进程控制的5种原语"><a href="#6-进程控制的5种原语" class="headerlink" title="6.进程控制的5种原语"></a>6.进程控制的5种原语</h4><p><code>进程的创建、终止、唤醒、阻塞、切换</code></p><p>（1）进程的创建原语</p><p><img src="/img/System/2.9.png"></p><p>（2）进程的终止原语</p><p><img src="/img/System/2.10.png"></p><p>（3）进程的唤醒和阻塞原语</p><ul><li>进程的阻塞和唤醒原语是成对存在的，必须成对使用</li><li>阻塞原语是由被阻塞进程自我调用实现的</li><li>唤醒原语是由一个被唤醒进程合作或被其他相关进程调用实现的</li></ul><p><img src="/img/System/2.11.png"></p><p>（4）进程的切换原语</p><p><img src="/img/System/2.12.png"></p><h3 id="2-1-4-进程之间的通信"><a href="#2-1-4-进程之间的通信" class="headerlink" title="2.1.4 进程之间的通信"></a>2.1.4 进程之间的通信</h3><p><img src="/img/System/2.13.png"></p><h4 id="1-什么是进程通信？"><a href="#1-什么是进程通信？" class="headerlink" title="1.什么是进程通信？"></a>1.什么是进程通信？</h4><p>顾名思义，进程通信就是指进程之间的信息交换。</p><p>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。</p><p><code>为了保证安全，一个进程不能直接访问另一个进程的地址空间</code>但是进程之间的信息交换又是必须实现的，为了保证进程间的安全通信，操作系统提供了一些方法：共享存储、消息传递、管道通信。</p><h4 id="2-共享存储"><a href="#2-共享存储" class="headerlink" title="2.共享存储"></a>2.共享存储</h4><ul><li>共享一块大家都可以访问的空间，一次只能有一个进程进行读或写操作</li></ul><p><img src="/img/System/2.14.png"></p><h4 id="3-管道通信"><a href="#3-管道通信" class="headerlink" title="3.管道通信"></a>3.管道通信</h4><p>“管道”是指用于连续读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。</p><p><img src="/img/System/2.15.png"></p><ol><li>管道只能采用半双工通信，某一时间段内只能实现单向的传输，如果要实现双向同时通信，则需要设置两个管道。</li><li>各进程要互斥的访问管道</li><li>数据以字符的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。</li><li>如果没写满，就不允许读。如果没读空，就不允许写。</li><li>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。</li></ol><h4 id="4-消息传递"><a href="#4-消息传递" class="headerlink" title="4.消息传递"></a>4.消息传递</h4><ul><li>发送消息的进程将消息头写好，接受消息进程根据消息头读取信息或寻找信封是哪一个</li></ul><p><img src="/img/System/2.16.png"></p><h3 id="2-1-5-线程概念与多线程模型"><a href="#2-1-5-线程概念与多线程模型" class="headerlink" title="2.1.5 线程概念与多线程模型"></a>2.1.5 线程概念与多线程模型</h3><p><img src="/img/System/2.17.png"></p><h4 id="1-为什么要引入线程？"><a href="#1-为什么要引入线程？" class="headerlink" title="1.为什么要引入线程？"></a>1.为什么要引入线程？</h4><p>有的进程可能需要“同时”做很多事，而传统的进程只能串行的执行一系列程序，为此，引入线程，来增加并发度。</p><h4 id="2-什么是线程？"><a href="#2-什么是线程？" class="headerlink" title="2.什么是线程？"></a>2.什么是线程？</h4><ul><li>可以把线程理解成“轻量级进程”</li><li>线程是一个基本的CPU执行单元，也是程序执行流的最小单位，引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提高了系统的并发率，使得一个进程内也可以并发处理各种任务（如QQ视频，文字聊天，传文件）</li><li>引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）</li></ul><h4 id="3-引入进程带来的变化及进程与线程的比较"><a href="#3-引入进程带来的变化及进程与线程的比较" class="headerlink" title="3.引入进程带来的变化及进程与线程的比较"></a>3.引入进程带来的变化及进程与线程的比较</h4><p><img src="/img/System/2.18.png"></p><h4 id="4-线程的属性"><a href="#4-线程的属性" class="headerlink" title="4.线程的属性"></a>4.线程的属性</h4><p><img src="/img/System/2.19.png"></p><h4 id="5-线程的实现方式"><a href="#5-线程的实现方式" class="headerlink" title="5.线程的实现方式"></a>5.线程的实现方式</h4><ul><li>线程的实现分为两类：用户级线程（User-Level Thread,UTL）和内核级线程（Kernel-Level Thread,KTL）。内核级线程又称内核支持的线程</li></ul><p>（1）用户级线程</p><p><img src="/img/System/2.20.png"></p><p>（2）内核级线程</p><p><img src="/img/System/2.21.png"></p><p>（3）特殊的组合方式及重点注意</p><p><img src="/img/System/2.22.png"></p><h4 id="6-多线程模型"><a href="#6-多线程模型" class="headerlink" title="6.多线程模型"></a>6.多线程模型</h4><p><img src="/img/System/2.23.png"></p><p><img src="/img/System/2.24.png"></p><p><img src="/img/System/2.25.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>System</tag>
      
      <tag>408考研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Instruction of Algorithm</title>
    <link href="/Algorithm/"/>
    <url>/Algorithm/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/AllAlgorithm.png" alt="《Instruction of Algorithm (Fourth Edition)》"></p><p><img src="/img/Algorithm2.png" alt="《算法导论》（第3版）"></p><div class="note note-warning">            <p>本文内容根据博主自身理解，同时结合《Instruction of Algorithm (4th Edition)》和《算法导论》（第三版）编写。</p><p>PS：借鉴了很多原书中的内容，因为写的太好了……</p>          </div><h2 id="Part-1-The-Role-of-Algorithms-in-Computing"><a href="#Part-1-The-Role-of-Algorithms-in-Computing" class="headerlink" title="Part 1 The Role of Algorithms in Computing"></a>Part 1 The Role of Algorithms in Computing</h2><h3 id="1-Algorithms"><a href="#1-Algorithms" class="headerlink" title="1. Algorithms"></a>1. Algorithms</h3><p><strong>算法</strong>：（非形式的说）就是定义任何良定义的计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出。</p><p><code>Informally, an algorithm is any well-defined computational procedure that takes some value, or set of values, as input and produces some value, or set of values, as output in a finite amount of time.</code></p><p><strong>输入</strong></p><p><strong>输出</strong></p><h2 id="Part-2-Getting-Started"><a href="#Part-2-Getting-Started" class="headerlink" title="Part 2 Getting Started"></a>Part 2 Getting Started</h2><p><a href="https://polaris516.github.io/SortAlgorithm/">手撕排序算法</a></p><p><img src="/"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
