<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于Springboot + Scrapy + Vue的信息快检索平台</title>
    <link href="/DataWeb/"/>
    <url>/DataWeb/</url>
    
    <content type="html"><![CDATA[<p><code>本次博客内容先瞻：</code></p><span class="label label-primary">text</span>本次博客，我们要实现利用 Scrapy 框架对网站数据进行爬取后存储到MySQL数据库中，然后使用 Vue 写一个Web网站，最后利用 Springboot 框架编写后端接口，将数据库的内容渲染到网站，实现一个简单的信息快检索平台。]]></content>
    
    
    
    <tags>
      
      <tag>Springboot</tag>
      
      <tag>Vue</tag>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Compilers</title>
    <link href="/Compeilers/"/>
    <url>/Compeilers/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    
    <tags>
      
      <tag>Compilers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Organization</title>
    <link href="/ComputerOrganization/"/>
    <url>/ComputerOrganization/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><div class="note note-warning">            <p>本文是介绍计算机组成原理，覆盖408考点，但是着重点是以国外教材为主。</p>          </div><p>博客参考书籍：</p><h2 id="第一章-概论"><a href="#第一章-概论" class="headerlink" title="第一章 概论"></a>第一章 概论</h2><h3 id="1-1-1-计算机的软硬件的概念"><a href="#1-1-1-计算机的软硬件的概念" class="headerlink" title="1.1.1 计算机的软硬件的概念"></a>1.1.1 计算机的软硬件的概念</h3><p>计算机系统由“硬件”和“软件”两大部分组成。</p><p>​硬件：计算机的实体部分，它由看得见摸得着的各种电子元器件，各类光、电、机设备的实物组成，如主机，外部设备等。</p><p>​软件：它看不见摸不着，由人们事先编制的具有各类特殊功能的程序组成。</p><h3 id="1-1-2-计算机系统的层次结构"><a href="#1-1-2-计算机系统的层次结构" class="headerlink" title="1.1.2 计算机系统的层次结构"></a>1.1.2 计算机系统的层次结构</h3><p><strong>五个层级 三种语言 两种程序</strong></p><blockquote><p>编译程序高级语言高级语言级</p><p>​   汇编语言 汇编语言级</p><p>​   操作系统级</p><p>解释程序—————————————————–</p><p>​机器语言传统语言级</p><p>​   微程序设计级</p></blockquote><h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2."></a>1.2.</h3><h3 id="1-1-3-计算机的发展"><a href="#1-1-3-计算机的发展" class="headerlink" title="1.1.3 计算机的发展"></a>1.1.3 计算机的发展</h3><table><thead><tr><th>发展阶段</th><th>时间</th><th>逻辑元件</th><th>速度（次&#x2F;秒）</th></tr></thead><tbody><tr><td>一代</td><td>1946 - 1957</td><td>电子管</td><td>几千~几万</td></tr><tr><td>二代</td><td>1958 - 1964</td><td>晶体管</td><td>几万~几十万</td></tr><tr><td>三代</td><td>1964 - 1971</td><td>中小规模集成电路</td><td>几十万~几百万</td></tr><tr><td>四代</td><td>1972 - 今</td><td>大规模和超大规模集成电路</td><td>上千万~万亿</td></tr></tbody></table><p><strong>摩尔定律：</strong>集成电路上的晶体管数量每18个月就会翻一番，所以每18个月计算机的处理效率就会提高一倍。</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>《Computer Organization And Design RISC-V edition》<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>408</tag>
      
      <tag>Computer Organization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/Linux/"/>
    <url>/Linux/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AndroidApp</title>
    <link href="/AndroidApp/"/>
    <url>/AndroidApp/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-应用开发模式"><a href="#Android-应用开发模式" class="headerlink" title="Android 应用开发模式"></a>Android 应用开发模式</h1><div class="note note-primary">            <p>本内容结合博主自己开发Android App的经历，在这中间遇到很多的波折，将这些整理下来并且给予初学者一个帮助，本文将通过最简单的方式带你入门，并且独自开发一个app。</p>          </div><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>参考资料：《Android Sudio开发实践——从零基础到App上线》欧阳燊<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>参考内容：……<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>软件开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>System Operation</title>
    <link href="/System/"/>
    <url>/System/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><div class="note note-primary">            <p>本文主要针对408考研内容编写，以及Linux等操作。</p>          </div><h2 id="1-1-操作系统简介"><a href="#1-1-操作系统简介" class="headerlink" title="1.1 操作系统简介"></a>1.1 操作系统简介</h2><p><code>操作系统能做什么？</code></p><div class="note note-warning">            <ul><li>从用户的角度：<ol><li>提供良好的用户界面</li><li>标准的函数库</li><li>使得编程更加方便并且不容易出错</li></ol></li><li>从系统的角度：<ol><li>管理资源（硬件资源、处理机、存储器、设备；信息资源【文件】）</li><li>解决申请资源时产生的冲突</li><li>阻止错误的产生和计算机不正当的使用</li></ol></li></ul>          </div><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p><font color="red">操作系统（Operation System，OS）</font>：是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本你爹系统软件。</p><blockquote><ul><li><p>An operating system acts an intermediary between user of a computer and the computer</p><p>  hardware.</p><ul><li>操作系统充当计算机⽤⼾和计算机硬件之间的中介</li></ul></li><li><p>The purpose of an operating system is to provide an environment in which a user can execute</p><p>  programs in a convenient and efficient manner.</p><ul><li>操作系统的⽬的是提供⼀个⽤⼾可以⽅便和有效地执⾏程序的环境</li></ul></li><li><p>An operating system is software that manages the computer hardware.</p><ul><li>操作系统是管理计算机硬件的软件</li></ul></li></ul></blockquote><p><img src="/img/System/System_1.1.png" alt="现代计算机硬件结构"></p><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><div class="note note-success">            <p>这里的内容以及和下面的<strong>存储器</strong>，<strong>I&#x2F;O设备</strong>，<strong>总线</strong>等都是计算机组成原理中的重要内容，在本文中也是按照书中给的内容进行叙述。下面有链接可以查看具体的讲解。（部分内容已经脱离408考点，主要是知识扩展）</p>          </div><blockquote><p>处理器（中央处理器（Central Processing Unit）—— CPU）：</p><ul><li><p>CPU工作的基本周期是：提取指令，译码分析，执行指令。（接化发！<code>链接中有讲到</code>）</p></li><li><p>CPU内部包含若干寄存器</p><ul><li><p>通用寄存器：</p><p>  ​用来存放关键变量和中间结果。</p></li><li><p>专用寄存器：</p><ul><li><p>程序计数器（PC）：</p><p>  ​PC中保存下面要提取指令的内存地址。</p></li><li><p>栈指针寄存器：</p><p>  ​存放指向当前内存栈的顶端的指针；该栈中保存有关函数（过程）调用时的现场信息，包括输入参数、局部变量和未在寄存器中保存的临时变量。</p><p>  ​程序执行过程中调用的每个函数在栈中站有一个帧面。</p></li><li><p>程序状态字（PSW）：</p><p>  ​条件码位、CPU优先级、程序执行模式（<strong>用户态</strong>或者<strong>核心态</strong>）和各种其他控制位。</p><p>  ​在系统调用和I&#x2F;O中PSW起重要作用。</p></li></ul></li></ul></li><li><p>处理机执行状态——保护操作系统程序，防止收到用户程序的损害：</p><ul><li><p>用户态</p><p>  ​用户程序（各种应用程序、工具、例程等）在用户态下执行，它们权限较低，只能执行指令集中非特权指令。</p></li><li><p>核心态（系统态、管理态）</p><p>  ​处于核心态，有较高特权，可以执行所有指令，包括普通用户程序中不能使用的<strong>特权指令</strong>，从而能对<strong>所有寄存器</strong>和<strong>内存</strong>进行访问，以及<strong>启动I&#x2F;O操作</strong>等。</p></li></ul></li></ul><p></p></blockquote><p><a href="https://polaris516.github.io/CO_CPU">中央处理器——CPU</a></p><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><blockquote><p>存储器（memory）：按照速度、容量和成本划分，存储器系统构成一个层次结构。（如图1.2）</p><ul><li><p>顶层是CPU的内部寄存器，速度和CPU一样快，存取它们没有延迟。但成本高，容量小，通常小于1KB</p></li><li><p>高速缓存：</p><p>  ​当程序需要读取具体信息时，Cache硬件先查看它是否在Cache中，如果在其中（“命中”），就直接使用它；反之，就从内存中获取该信息，并把它放入Cache中。小于4MB</p></li><li><p>内存（主存）：</p><ul><li>存储器系统的主力，也称作RAM（随机存取存储器）</li><li>CPU可以直接存取内存及寄存器和Cache中的信息。</li><li>机器执行的指令及所用的数据必须先存放在内存及Cache和寄存器中。</li><li>内存中存放的信息是易失的，当机器电源被关闭后，内存中的信息就全部丢失了。</li></ul></li><li><p>磁盘（硬盘、辅助存储器或者辅存、外存）：</p><ul><li>对内存的扩展</li><li>磁盘上可以永久保留数据，容量特别大</li><li>磁盘上数据的存取速度低于内存存取速度</li></ul></li><li><p>磁带</p><ul><li>数据永久保存，容量很大，存取速度很慢，不适宜随机存取。</li><li>主要作为文件系统的后备，存放不常用的信息或用做系统间的传送信息的介质。</li></ul></li><li><p>其他存储器：如软盘，光盘（CD-ROM）、U盘等</p></li></ul></blockquote><p><img src="/img/System/1.2.1.png" alt="图1.2"></p><p><a href="https://polaris516.github.io/CO_Memory">存储器——Memory</a></p><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h3><blockquote><ul><li><p>控制器：</p><p>  ​控制器是I&#x2F;O设备的电子部分，它协调和控制一台或多台I&#x2F;O设备的操作，实现设备操作与整个系统操作的同步。</p></li><li><p>设备:</p><p>  ​本身的对外接口相当简单，实际上他们隐藏在控制器后面</p></li></ul><p>设备驱动程序：向控制器发布命令并接收其回答信息的软件。</p></blockquote><ul><li>存储器只是众多IO设备的一种，IO设备是计算机体系结构中种类最丰富的设备类型，而且它有着很强的扩展性</li><li>管理IO设备是操作系统非常重要的组成成分，操作系统中有一个专门的IO子系统负责完成这项工作。</li></ul><p><a href="https://polaris516.github.io/CO_I-O">I&#x2F;O设备</a></p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><blockquote><ul><li><p>数据总线：</p><p>  ​计算机各部件之间传送数据的通道，其宽度随字长而定</p><p>  ​数据总线是双向总线，即两个方向都能传送数据</p></li><li><p>地址总线：</p><p>  ​从CPU送来地址的地址线，它可以是存储器的地址，也可以是IO设备控制器中中控制寄存器或数据寄存器的地址</p></li><li><p>控制总线：</p><p>  ​在该线上出现的信号是各个模块之间传送数据时所需的全部控制信号</p></li></ul></blockquote><h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><p><img src="/img/System/1.2.2.png"></p><h4 id="1-并发："><a href="#1-并发：" class="headerlink" title="1.并发："></a>1.并发：</h4><p><code>并发</code>：两个或多个事件在同一个时间间隔内发生，这些事件在宏观上是同时发生的，在微观上是交替发生的，操作系统的并发性指系统中同时存在着多个运行的程序</p><p><code>并行</code>：两个或多个事件在同一个时刻发生</p><p>一个单核（CPU）同一时刻只能执行一个程序，因此操作系统会协调多个程序使他们交替进行（这些程序在宏观上是同时发生的，在微观上是交替进行的）</p><p>操作系统是伴随着“多道程序技术出现的”，因此操作系统和并发是一同诞生的</p><p>在如今的计算机中，一般都是多核CPU的，即在同一时刻可以并行执行多个程序。</p><h4 id="2-共享："><a href="#2-共享：" class="headerlink" title="2.共享："></a>2.共享：</h4><ul><li>资源共享即共享，是指系统中的资源可以<code>供内存中多个并发执行的进程</code>共同使用</li><li>共享分为两类：互斥共享和同时共享<ol><li>互斥共享<ul><li>计算机中的某个资源在一段时间内只能允许一个进程访问，别的进程没有使用权</li><li>临界资源（独占资源）：在一段时间内只允许一个进程访问，别的进程没有使用权</li><li>eg：QQ和微信视频，同一段时间内摄像头只能分配给其中一个进程</li></ul></li><li>同时共享<ul><li>计算机中的某个资源在一段时间内可以同时允许多个进程访问</li><li>同时共享通常要求一个请求分为几个时间片段间隔的完成，即交替进行，“分时共享”</li><li>这里的同时指在宏观上是同时的，在微观上是交替进行访问的，只是CPU处理速度很快，我们感觉不到。在宏观上感觉是在同时进行</li><li>eg：比如QQ在发送文件A，微信在发送文件B，宏观上两个进程A和B都在访问磁盘，在我们看来是同时进行的，但是在微观上两个进程A和B是交替进行的，只是时间太短，cpu处理速度太快，我们感觉不到。</li><li><code>注意</code>：有时候多个进程可能真的是在同时进行资源访问，比如玩游戏时可以放音乐，游戏声音和音乐声音都能听见</li></ul></li></ol></li></ul><h4 id="3-并发和共享的关系"><a href="#3-并发和共享的关系" class="headerlink" title="3.并发和共享的关系"></a>3.并发和共享的关系</h4><p>并发性指计算机系统中同时存在着多个运行着的程序</p><p>共享性是指系统中的资源可供内存中多个并发执行的进程共同使用</p><ul><li>从上述例子来看二者之间的关系：<ol><li>两个进程正在并发执行（并发性）</li><li>需要共享地访问硬盘资源（共享性）</li></ol></li></ul><p><code>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义</code></p><p><code>如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发</code></p><h4 id="4-虚拟"><a href="#4-虚拟" class="headerlink" title="4.虚拟"></a>4.虚拟</h4><blockquote><p>多道程序设计：是指在计算机内存中同时存放几道互相独立的程序，使它们在管理程序控制之下，相互穿插的运行。两个或两个以上的程序在计算机系统中同处于开始到结束之间的状态。这就称为多道程序设计。多道程序技术运行的特征：多道、宏观上并行、微观上串行。</p></blockquote><ul><li>虚拟是把一个物理上的实体变为若干逻辑上的对应物</li><li>物理实体（前者）是实际存在的；而后者是虚的，是用户感觉上的事务</li><li>虚拟技术：用于实现虚拟的技术</li><li>虚拟处理器（CPU）：通过多道程序设计技术，采用让多道程序并发执行的方法，分时来使用一个CPU，实际物理上只有一个CPU，但是用户感觉到有多个CPU</li><li>虚拟存储器：从逻辑上扩充存储器容量，用户感觉到的但实际不存在的存储器</li><li>虚拟设备：将一台物理设备虚拟为逻辑上的多台设备，使多个用户在同一时间段内访问同一台设备，即同时共享，用户宏观上感觉是同时的，但实际上是微观交替访问同一台设备</li><li>操作系统的虚拟技术可归纳为：<ul><li>时分复用技术：如处理器的分时共享</li><li>空间复用技术：如虚拟处理器</li></ul></li></ul><p><code>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此没有并发性，就谈不上虚拟性</code></p><h4 id="5-异步"><a href="#5-异步" class="headerlink" title="5.异步"></a>5.异步</h4><ul><li>异步：多道程序环境允许多个程序并发执行，但由于资源有限，如cpu只有一个，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进。</li><li>比如A进程正在占用CPU计算，B进程这时也想占用CPU计算，B进程只有等，等A进程算完了，A进程去访问磁盘资源了，这时B进程再占用CPU进行计算，B进程还没计算完，A进程从磁盘取出资源了，A进程发现B这时在占用CPU，这时A进程就需要等待，等B算完后再继续到CPU中进行计算。由于每个进程占用资源的时间不固定，所以进程的执行以不可预知的速度前进</li></ul><h2 id="1-2-处理器系统"><a href="#1-2-处理器系统" class="headerlink" title="1.2 处理器系统"></a>1.2 处理器系统</h2><p><img src="/img/System/1.3.1,png"></p><h3 id="单处理器系统"><a href="#单处理器系统" class="headerlink" title="单处理器系统"></a>单处理器系统</h3><ul><li>Single-progress System</li><li>只有一颗注CPU，执行通用指令集</li><li>带有其他专用处理器，为特定设备服务，如：磁盘、键盘、图形控制器等<ul><li>它们能够执行的指令有限，不处理用户进程</li><li>操作系统会向它们发出任务，并监控它们的状态</li></ul></li></ul><h3 id="多处理器系统"><a href="#多处理器系统" class="headerlink" title="多处理器系统"></a>多处理器系统</h3><ul><li>Multi processor&#x2F;Muliticore System</li><li>有两个或多个紧密通信的CPU，它们共享计算机总线、时钟、内存和外设等。</li></ul><h3 id="集群系统"><a href="#集群系统" class="headerlink" title="集群系统"></a>集群系统</h3><ul><li>Clustered System</li><li>该系统由若干节点（Node）通过网络连接在一起，每个节点可为单处理器系统或多处理器系统，节点之间是松耦合（loosely coupled)关系<ul><li>高可用性（high availability）</li><li>高性能计算（high-performance computing)</li></ul></li></ul><h3 id="单道单用户模式"><a href="#单道单用户模式" class="headerlink" title="单道单用户模式"></a>单道单用户模式</h3><p><img src="/img/System/1.3.png" alt="单道单用户模式"></p><h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><ul><li>操作系统最重要的一点是具有多道程序的能力</li><li>单道程序不能让CPU和IO设备始终忙碌，多道程序设计通过安排任务使用的CPU总有一个执行任务，从而提高CPU利用率</li><li>实现的硬件保证：处理器和IO设备具有并行工作的能力</li></ul><h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><ul><li>分时系统也称多任务系统，是多道程序设计的自然延伸</li><li>允许多个用户共享一台计算机<ul><li>用户只有输入和输出设备</li><li>分时系统为每个用户轮流分配等量的CPU时间</li><li>用户从发出指令得到得到即时结果的时间称为响应时间</li></ul></li><li>第一个分时系统CTSS由MIT于1962年开发出来</li></ul><h2 id="1-3-操作系统的发展历程："><a href="#1-3-操作系统的发展历程：" class="headerlink" title="1.3 操作系统的发展历程："></a>1.3 操作系统的发展历程：</h2><p><img src="/img/System/1.3.2.png"></p><h2 id="1-4-操作系统的运行机制和体系结构"><a href="#1-4-操作系统的运行机制和体系结构" class="headerlink" title="1.4 操作系统的运行机制和体系结构"></a>1.4 操作系统的运行机制和体系结构</h2><h3 id="1-4-1-操作系统的运行机制和体系结构"><a href="#1-4-1-操作系统的运行机制和体系结构" class="headerlink" title="1.4.1 操作系统的运行机制和体系结构"></a>1.4.1 操作系统的运行机制和体系结构</h3><h4 id="1-操作系统的运行机制和体系结构"><a href="#1-操作系统的运行机制和体系结构" class="headerlink" title="1.操作系统的运行机制和体系结构"></a>1.操作系统的运行机制和体系结构</h4><p><img src="/img/System/1.5.1.png"></p><h4 id="2-操作系统体系结构类比"><a href="#2-操作系统体系结构类比" class="headerlink" title="2.操作系统体系结构类比"></a>2.操作系统体系结构类比</h4><p>类比：</p><p>操作系统体系结构问题与企业的管理问题很相似。</p><p>内核就是企业的管理层，负责一些重要的工作。只有管理层才能执行特权指令，普通员工只能执行非特权指令。用户态，核心态之间的切换相当于普通员工和管理层之间的工作交接</p><p>大内核：企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高；缺点是组织结构混乱，难以维护</p><p>微内核：随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护；缺点是效率低</p><h4 id="3-操作系统用户态和核心态的转换"><a href="#3-操作系统用户态和核心态的转换" class="headerlink" title="3.操作系统用户态和核心态的转换"></a>3.操作系统用户态和核心态的转换</h4><p>“用户态 -&gt; 核心态”是通过中断实现的。并且中断是唯一途径。“核心态 -&gt; 用户态”的切换是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”</p><h3 id="1-4-2-中断和异常"><a href="#1-4-2-中断和异常" class="headerlink" title="1.4.2 中断和异常"></a>1.4.2 中断和异常</h3><p><img src="/img/System/1.5.2.png"></p><p> 中断</p><ul><li>当有事件（event）发生时，CPU会收到一个中断（interrupt）信号，可以是硬中断也可以是软中断</li><li>CPU会停下正在做的事，转而执行中断处理程序，执行完毕会回到之前被中断的地方继续执行</li><li>Operation System is an Interrupt driven system<ul><li>操作系统是一个由中断驱动的系统</li></ul></li></ul><h3 id="1-4-3-系统调用（执行过程、访管指令、库函数与系统调用）"><a href="#1-4-3-系统调用（执行过程、访管指令、库函数与系统调用）" class="headerlink" title="1.4.3 系统调用（执行过程、访管指令、库函数与系统调用）"></a>1.4.3 系统调用（执行过程、访管指令、库函数与系统调用）</h3><p><img src="/img/System/1.4.3"></p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1>]]></content>
    
    
    
    <tags>
      
      <tag>System</tag>
      
      <tag>Linux</tag>
      
      <tag>408考研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Instruction of Algorithm</title>
    <link href="/Algorithm/"/>
    <url>/Algorithm/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/AllAlgorithm.png" alt="《Instruction of Algorithm (Fourth Edition)》"></p><p><img src="/img/Algorithm2.png" alt="《算法导论》（第3版）"></p><div class="note note-warning">            <p>本文内容根据博主自身理解，同时结合《Instruction of Algorithm (4th Edition)》和《算法导论》（第三版）编写。</p><p>PS：借鉴了很多原书中的内容，因为写的太好了……</p>          </div><h2 id="Part-1-The-Role-of-Algorithms-in-Computing"><a href="#Part-1-The-Role-of-Algorithms-in-Computing" class="headerlink" title="Part 1 The Role of Algorithms in Computing"></a>Part 1 The Role of Algorithms in Computing</h2><h3 id="1-Algorithms"><a href="#1-Algorithms" class="headerlink" title="1. Algorithms"></a>1. Algorithms</h3><p><strong>算法</strong>：（非形式的说）就是定义任何良定义的计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出。</p><p><code>Informally, an algorithm is any well-defined computational procedure that takes some value, or set of values, as input and produces some value, or set of values, as output in a finite amount of time.</code></p><p><strong>输入</strong></p><p><strong>输出</strong></p><h2 id="Part-2-Getting-Started"><a href="#Part-2-Getting-Started" class="headerlink" title="Part 2 Getting Started"></a>Part 2 Getting Started</h2><p><a href="https://polaris516.github.io/SortAlgorithm/">手撕排序算法</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
