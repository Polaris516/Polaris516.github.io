<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CyberNetworks</title>
    <link href="/CyberNetworks/"/>
    <url>/CyberNetworks/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>408</tag>
      
      <tag>Cyber networks</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue</title>
    <link href="/Vue/"/>
    <url>/Vue/</url>
    
    <content type="html"><![CDATA[<h1>Vue</h1><h2 id="Vue的不同创建方式">Vue的不同创建方式</h2><h3 id="一、Vite-和-Vue-CLI-是什么？">一、Vite 和 Vue CLI 是什么？</h3><h4 id="Vue-CLI-的特点">Vue CLI 的特点</h4><p>Vue CLI 是Vue 2 最好的前端构建工具，是基于Webpack之上，是 Webpack 的超集</p><ul><li>Vue CLI基于Webpack构建，配置好了打包规则</li><li>内置热模块重载的开发服务器</li><li>有丰富的官方插件合集，站在webpack庞大的社区资源上</li><li>友好的图形化创建和管理Vue项目界面</li></ul><p>Vue CLI 在服务器启动之前，要把所有代码打包成Bundle在启动服务。这就是为什么启动一些大型项目时特别慢的原因。VIte做了改善</p><h4 id="Vite的特点">Vite的特点</h4><p>Vite 通过一开始将应用中的模块区分为依赖和源码两类，改进了开发服务器的启动时间</p><ul><li>依赖：大多为在开发时不会变动的纯 JavaScript 。一些较大的依赖（例如有上百个模块的组件库）处理的代价很高。依赖通常会存在多种模块化格式，Vite 会使用esbuild 预构建依赖。esbuild使用 Go 编写，并且比以 JavaScript 编写的打包器预购建依赖快10~100倍</li><li>源码：通常包含一些并非直接是 JavaScript 的文件，需要转换，时常会被编辑。同时，并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）</li></ul><h3 id="二、Vite-和-Vue-CLI-的区别">二、Vite 和 Vue CLI 的区别</h3><p>Vite 是基于 ES6 Modules，在生产环境下打包使用的是Rollup。vue-cli基于webpack封装，生产环境和开发环境都是基于Webpack打包。所以两者在生产环境下都是基于源代码文件打包。但在开发环境中，两者有所不同。Vite 在开发环境下，基于原生ES6，无需对代码进行打包。浏览器可以直接调用，所以Vite因为基于浏览器的原生功能，省掉了打包过程，在开发环境中体验及其愉快。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot框架学习</title>
    <link href="/SpringBoot%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    <url>/SpringBoot%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1>Springboot 系统学习开发</h1><p><img src="D:/ProgramData/Myblog/source/_posts/assets/image-20241220110617829.png" alt="image-20241220110617829"></p><p><img src="D:/ProgramData/Myblog/source/_posts/assets/image-20241220110626329.png" alt="image-20241220110626329"></p><hr><h2 id="简单流程框架">简单流程框架</h2><blockquote><p>Controller （C - 接收请求）</p><p>​    ↓</p><p>Service（负责业务逻辑）</p><p>​↓</p><p>Repository/DAO（负责数据访问）</p><p>​↓</p><p>Entity（数据模型）</p></blockquote><hr><h4 id="config-配置层">config(配置层)</h4><p>作用：</p><ul><li>用于存放项目的各种配置文件和类，包括Spring Boot 的配置，数据库配置、安全配置等</li><li>主要是负责初始化和设置项目的相关参数</li></ul><p>常见内容：</p><ul><li>数据源配置<code>DataSourceConfig</code></li><li>跨域配置<code>CorsConfig</code></li><li>安全框架配置（如<code>Spring Security</code>的配置类）</li><li>定时任务配置<code>SchedulerConfig</code></li><li>自定义配置类</li></ul><h4 id="controller（控制层）">controller（控制层）</h4><p>作用：</p><ul><li>接收并处理来自客户端的请求（例如HTTP请求）</li><li>调用<code>service</code>层完成具体业务逻辑</li><li>将响应结果返回给客户端（通常是JSON数据）</li></ul><p>常见内容</p><ul><li>RESTful API 接口定义</li><li>路由管理（<code>@RequestMapping</code>，<code>@GerMapping</code>，<code>@PostMapping</code>等）</li><li>参数校验和异常处理</li></ul><hr><h4 id="dao（数据访问层）">dao（数据访问层）</h4><p>作用：</p><ul><li>数据库访问层，主要是与数据库直接交互</li><li>负责数据的CRUD操作（增删改查）</li><li>通常使用 Spring Data JPA 、MyBatis或者其他ORM框架来操作数据库</li></ul><p>常见内容：</p><ul><li>数据库实体类对应的 Repository （如<code>JpaRepository</code>）</li><li>数据访问的接口定义</li></ul><h4 id="entity（实体层）">entity（实体层）</h4><p>作用：</p><ul><li>用于定义数据库中表的映射关系，也叫做领域模型或数据模型</li><li>通常是一个普通的POJO类（Plain Old Java Object），包含字段，构造方法，Getter和Setter方法</li></ul><p>常见内容：</p><ul><li>JPA 注解（<code>@Entity</code>，<code>@Table</code>，<code>@Column</code>等）</li><li>用于持久化的数据类</li></ul><h4 id="service（服务层）">service（服务层）</h4><p>作用：</p><ul><li>负责业务逻辑处理，是连接控制层和数据访问层桥梁</li><li>在<code>service</code>层调用<code>dao</code>层的方法完成数据操作</li><li>包括具体的业务逻辑实现</li></ul><p>常见内容</p><ul><li>业务逻辑代码</li><li>调用DAO层方法</li><li>事务管理（<code>@Transactional</code>）</li></ul><hr><p>五层结构：</p><ol><li><code>config</code> 提供了统一的项目配置</li><li><code>controller</code> 负责处理客户端请求</li><li><code>service</code> 执行业务逻辑</li><li><code>dao</code> 负责与数据库交互</li><li><code>entity</code>是数据的载体</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-attribute">src</span><br> └── <span class="hljs-selector-tag">main</span><br>     └── java<br>         └── com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.project</span><br>             ├── config                <span class="hljs-comment">// 配置类 (如拦截器、全局设置等)</span><br>             ├── controller            <span class="hljs-comment">// 控制器类 (如你的 Rest 接口)</span><br>             ├── service               <span class="hljs-comment">// 服务层</span><br>             ├── model                 <span class="hljs-comment">// 实体类 (如数据库表对应的类)</span><br>             ├── dto                   <span class="hljs-comment">// 数据传输对象 (ApiResponse 可以放这里)</span><br>             ├── util                  <span class="hljs-comment">// 工具类 (通用工具)</span><br>             └── exception             <span class="hljs-comment">// 自定义异常处理相关类</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Uni-app 开发学习</title>
    <link href="/Uni-app-%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    <url>/Uni-app-%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1>Uniapp 学习</h1><h2 id="博客前瞻">博客前瞻</h2><p>​在本博客的内容就是学习Uniapp开发，通过Android studio学习Android app的开发到Uniapp的开发再到未来的Harmony app开发，我们进行到了第二步。</p><p>​这里的Uniapp的开发需要用到的东西有：<code>Hbuilder X</code>（开发工具）、Vue3、以及编写小程序的开发工具（微信小程序，抖音小程序等等可以自行安装）</p><p>​学习Uniapp开发需要具备一些基础知识：Vue3</p><p>​如果需要后续会将环境安装等教程以博客链接的形式上传到本博客中，大家可以自行消化。</p><p>​<strong>这里将Uniapp官方文档链接放在下面，这个博客不会将每个步骤都详细的写出来，因为这些都已经存在在官方文档中，本博客主要是针对一些基础补充或者入门引导，可以帮助你更好的融入Uniapp开发之中。</strong></p><p>​<a href="https://uniapp.dcloud.net.cn">Uniapp官方文档</a></p><p>​<a href="https://cn.vuejs.org/guide/introduction.html">Vue官方文档</a></p><blockquote><p>建议学习路线：<strong>博客前瞻</strong>（Vue官方文档 --&gt; Uniapp官方文档）–&gt; <strong>Uniapp基础组件操作</strong> --&gt; <strong>Uniapp上手实操</strong>（另一个博客内容,后续会补充链接）</p><p><font color=orange>在刚刚学习 Uniapp 中最好不要先看 **基础知识（必备）**篇，因为看了你也记住不了多少，不如遇到问题再回头查看，我觉得印象会更深，但是可以先看一下每个基础知识的标题，以方便你日后出现问题寻找。</font></p><p>在学习中如果遇到一些不清楚的地方可以从本博客的 **基础知识（必备）**章节进行学习，这里面提供部分学习时可能出现的问题（如有补充，评论提出）</p></blockquote><h2 id="基础知识（必备）">基础知识（必备）</h2><h3 id="Vue3入门学习">Vue3入门学习</h3><h4 id="Vue3和Vue2的区别">Vue3和Vue2的区别</h4><h4 id="CLI和Vite">CLI和Vite</h4><table><thead><tr><th>特性/方面</th><th><strong>Vue CLI</strong></th><th><strong>Vite</strong></th></tr></thead><tbody><tr><td><strong>构建方式</strong></td><td>使用 Webpack 构建</td><td>使用 ESBuild 和 Rollup 构建</td></tr><tr><td><strong>开发服务器</strong></td><td>传统的 Webpack Dev Server</td><td>原生 ESM 开发服务器（基于 ES Modules）</td></tr><tr><td><strong>初始构建速度</strong></td><td>较慢（依赖 Webpack 编译整个项目）</td><td>极快（只编译使用的模块）</td></tr><tr><td><strong>热更新速度（HMR）</strong></td><td>较慢，尤其是大型项目</td><td>极快，模块级更新</td></tr><tr><td><strong>配置灵活性</strong></td><td>高（基于 Webpack 的扩展性）</td><td>非常高（插件化，简单且灵活）</td></tr><tr><td><strong>生态系统支持</strong></td><td>完整支持 Vue 生态</td><td>原生支持 Vue，且对现代工具链有更好兼容</td></tr><tr><td><strong>默认支持</strong></td><td>Vue 2 和 Vue 3 都支持</td><td>更推荐 Vue 3，Vue 2 需额外插件支持</td></tr><tr><td><strong>目标用户</strong></td><td>适合传统项目和大型复杂项目</td><td>适合现代前端项目、小型或中型项目</td></tr><tr><td><strong>类型</strong></td><td>重量级脚手架，配置较多</td><td>轻量级工具，开箱即用</td></tr><tr><td><strong>构建产物体积</strong></td><td>产物稍大，优化需手动配置</td><td>产物更小，默认有较好的 Tree-Shaking</td></tr><tr><td><strong>适用框架</strong></td><td>专为 Vue 设计</td><td>不仅适用于 Vue，还支持 React、Svelte 等</td></tr><tr><td><strong>插件体系</strong></td><td>基于 Webpack 的插件</td><td>基于 Rollup 的插件，生态丰富</td></tr><tr><td><strong>现代特性支持</strong></td><td>对现代 JS 特性支持较慢</td><td>对现代 JS/CSS 特性支持原生</td></tr></tbody></table><h5 id="总结：Vue-CLI-和-Vite-的适用场景"><strong>总结：Vue CLI 和 Vite 的适用场景</strong></h5><table><thead><tr><th>工具</th><th><strong>适合场景</strong></th></tr></thead><tbody><tr><td><strong>Vue CLI</strong></td><td>- 需要构建 Vue 2 项目。 - 项目规模较大，依赖复杂的 Webpack 配置和插件体系。 - 团队对 Webpack 更熟悉或已有成熟的 Webpack 配置。</td></tr><tr><td><strong>Vite</strong></td><td>- 构建 Vue 3 项目，或新项目时优先选择。 - 需要更快的开发启动速度和热更新。 - 更轻量化的项目，使用现代前端工具链和特性（如 TypeScript、ES Modules）。</td></tr></tbody></table><h4 id="Uniapp基础模版">Uniapp基础模版</h4><p><a href="https://cn.vuejs.org/guide/quick-start.html">Vue官方文档</a></p><p>以下的内容我们将以Uniapp中的Vue写作方法为主：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这是一个Uniapp页面的基础模版：</p><p><code>&lt;script setup&gt;</code>：语法糖。我们要记住这个模版，后面在Uniapp中利用这个基础模版完成页面的创建。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这是 Vue2 的写法：</span><br><br>&lt;template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>Count:&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">            count.<span class="hljs-property">value</span>++;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">    </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        count,</span></span><br><span class="language-javascript"><span class="language-xml">        increment,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这是 Vue3 的写法：</span><br><br>&lt;template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>Count:&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    count.<span class="hljs-property">value</span>++;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="语法糖">语法糖</h4><p>语法糖是什么？</p><blockquote><p>语法糖（Syntactic sugar），也译为糖衣语法是由英国计算机科学家彼得·约翰·<a href="https://baike.baidu.com/item/%E5%85%B0%E8%BE%BE/1571737?fromModule=lemma_inlink">兰达</a>（Peter J. Landin）发明的一个术语，指<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/4456504?fromModule=lemma_inlink">计算机语言</a>中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E5%91%98/62748?fromModule=lemma_inlink">程序员</a>使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p><p>简单理解：语法糖可以看成是一个函数的集合体，在这个里面我们可以对某些函数或者实现进行简化操作，后面的内容也会提到这部分，随着后面的学习可以更好的理解这个语法糖的概念。</p></blockquote><h4 id="响应式基础">响应式基础</h4><p>1.什么是响应式网页？</p><p><code>响应式网页（Responsive Web Design）是一种网页设计和开发的技术，使网页能够在不同设备和屏幕尺寸上提供良好的用户体验，通过使用灵活的布局、自适应的图像和CSS媒体查询，响应式网页可以在各种设备（桌面电脑、笔记本、智能手机）上动态调整页面布局和内容显示方式。</code></p><p>2.Vue中的响应式</p><blockquote><p>Vue中的&quot;响应式&quot;指的是<strong>数据和视图之间的自动同步机制</strong></p><p>当数据发生变化时，视图会自动更新，而无需开发者手动操作DOM。这种机制通过 Vue 的响应式系统实现，使开发者可以更高效地管理状态和构建动态的用户界面。</p><ol><li><strong>数据驱动视图</strong>：视图直接依赖于数据，当数据变化时，视图会自动更新。</li><li><strong>自动依赖追踪</strong>：Vue 自动追踪哪些数据被使用，并在数据变化时更新相关部分，而非整个页面</li><li><strong>声明式编程</strong>：开发者只需声明&quot;数据如何影响视图&quot;，不需要手动操作DOM</li></ol></blockquote><h5 id="ref">ref</h5><ul><li>用于创建一个<strong>单值的响应式对象</strong></li><li>常用于处理基本数据类型（如字符串、数字、布尔值等）</li><li>响应式通过<code>.value</code>访问</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><br>count.<span class="hljs-property">value</span>++;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>);  <span class="hljs-comment">// 输出1</span><br></code></pre></td></tr></table></figure><p>​<strong>ref 的对象解包</strong>：</p><ul><li>​在<strong>template</strong>中，<strong>ref</strong> 的 <strong>.value</strong> 会被自动解包</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span>    <br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="computed">computed</h5><ul><li>用于创建计算属性</li><li>计算属性可以基于响应式数据动态计算值，并且具备缓存功能（只有依赖的数据发生变化时才会重新计算）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;reactive, computed&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>    <span class="hljs-attr">num1</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">num2</span>: <span class="hljs-number">10</span>,<br>&#125;)<br><br><span class="hljs-keyword">const</span> sum = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">num1</span> +state.<span class="hljs-property">num2</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum.<span class="hljs-property">value</span>);<br></code></pre></td></tr></table></figure><h4 id="组件">组件</h4><h5 id="v-bind（单向绑定）">v-bind（单向绑定）</h5><p><code>v-bind</code>：用于将<strong>父组件的数据</strong>或<strong>Vue数据</strong>绑定到<strong>HTML属性</strong>或<strong>子组件的props</strong>上，形成<strong>单向数据流</strong>。</p><p><strong>核心特点</strong>：</p><ul><li>数据流是单向的：Vue（数据） --&gt; HTML属性或子组件。</li><li>用户无法通过页面上的交互直接更改这些数据</li><li>用于动态绑定元素的属性、组件的props等。</li></ul><h5 id="v-model（双向绑定）">v-model（双向绑定）</h5><p><code>v-model</code>：是Vue的语法糖，用于实现双向数据绑定：Vue数据模型（父组件变量）和用户界面之间可以互相更新。</p><p><strong>核心特点</strong>：</p><ul><li><p>数据流向是<strong>双向的</strong>：</p><ul><li><p>Vue数据（模型）–&gt;用户界面（输入框、组件等）</p></li><li><p>用户界面（输入操作）–&gt;Vue数据（模型）</p></li></ul></li><li><p>常用于表单控件（如 input、 textarea等）或组件的值绑定</p></li><li><p>本质上是<code>v-bind</code>和<code>v-on</code>的语法糖</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">&quot;value&quot;</span> <span class="hljs-attr">v-on:input</span>=<span class="hljs-string">&quot;value = $event.target.value&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="v-bind-和-v-model-的区别对比"><strong><code>v-bind</code> 和 <code>v-model</code> 的区别对比</strong></h5><table><thead><tr><th><strong>特性</strong></th><th><strong><code>v-bind</code>（单向绑定）</strong></th><th><strong><code>v-model</code>（双向绑定）</strong></th></tr></thead><tbody><tr><td><strong>数据方向</strong></td><td>单向：Vue 数据（模型） → HTML/子组件</td><td>双向：Vue 数据 ↔ HTML/子组件</td></tr><tr><td><strong>用户操作是否修改数据</strong></td><td>不可以，用户无法通过界面直接修改绑定的数据</td><td>可以，用户的输入会实时同步到 Vue 数据模型</td></tr><tr><td><strong>常见使用场景</strong></td><td>动态绑定属性、传递 <code>props</code>、动态样式</td><td>表单控件输入、父子组件双向绑定</td></tr><tr><td><strong>本质</strong></td><td>数据的展示和传递</td><td>数据的展示和交互</td></tr><tr><td><strong>语法糖</strong></td><td>没有（需明确绑定属性）</td><td><code>v-bind:value</code> 和 <code>v-on:input</code> 的语法糖</td></tr><tr><td><strong>常见例子</strong></td><td>绑定图片 <code>src</code>，传递子组件 <code>props</code></td><td>输入框、选项框、组件中需要交互的值绑定</td></tr></tbody></table><hr><h4 id="生命周期钩子">生命周期钩子</h4><p><code>生命周期钩子</code>（Lifecycle Hooks）是指在应用程序或组件的生命周期中，不同阶段触发的一些预定义事件或函数。常见于现代前端框架（如Vue、React、Angular）和其他一些框架中。这些钩子提供了一种机制，让开发者能够在特定的时机执行代码，比如组件的初始化、更新或销毁等阶段。</p><h5 id="Vue生命周期钩子">Vue生命周期钩子</h5><p>Vue.js 的组件生命周期分为创建、挂载、更新和销毁四个阶段，各个阶段对应的钩子如下：</p><p><strong>创建阶段</strong></p><ul><li>beforeCreate：实例初始化之前调用此时无法访问data，method等</li><li>created：实例创建完成后调用，可访问data，method等，但尚未挂载到DOM</li></ul><p><strong>挂载阶段</strong></p><ul><li>beforeMount：在挂载到DOM之前调用</li><li>mounted：挂载到DOM后调用，此时可以操作真实的DOM</li></ul><p><strong>更新阶段</strong></p><ul><li>beforeUpdate：数据更新时调用，但未更新到DOM</li><li>updated：数据更新并渲染到DOM之后使用</li></ul><p><strong>销毁阶段</strong></p><ul><li>beforeUnmount（Vue3）/beforeDestroy（Vue2）：实力销毁之前调用</li><li>unmounted（Vue3）/destroyed（Vue2）：实力销毁后调用</li></ul><h5 id="Uniapp-生命周期函数">Uniapp 生命周期函数</h5><blockquote><p><font color=red>uniapp 页面的生命周期函数</font>与Vue的生命周期函数有所不同。</p></blockquote><p>在开发 uniapp Vue3版本的时候，需要在组合式 API 中需要先从&quot;@dcloudio/uni-app&quot;模块中导入才可以。</p><ul><li>onLoad：页面加载时触发，可以在此生命周期函数中进行页面初始化操作。</li><li>onShow：页面显示时触发，可以在此生命周期函数中进行页面展示相关的操作。</li><li>onReady：页面初次渲染完成时触发，可以在此生命周期函数中进行页面渲染完成后的操作。</li><li>onHide：页面隐藏时触发，可以在此生命周期函数中进行页面隐藏相关的操作。</li><li>onUnload：页面卸载时触发，可以在此生命周期函数中进行页面卸载相关的操作。</li></ul><p>其余生命周期：<a href="https://uniapp.dcloud.net.cn/tutorial/page.html#lifecycle">页面生命周期</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">onReachBottom</span>()是页面级别的触底钩子，不能在组件中使用，同时需要在page.<span class="hljs-property">json</span>中进行注册：<br><br>&#123;<br>  <span class="hljs-string">&quot;pages&quot;</span>: [<br>    &#123;<br>      <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;pages/forum/forum&quot;</span>,<br>      <span class="hljs-string">&quot;style&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;onReachBottomDistance&quot;</span>: <span class="hljs-number">50</span><br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="uniapp-中组件生命周期函数和页面生命周期函数的执行顺序">uniapp 中组件生命周期函数和页面生命周期函数的执行顺序</h5><p>不包含组件的页面：</p><p>onLoad &gt; onShow &gt; onReady</p><p>包含组件的页面：</p><p>onLoad &gt; onShow &gt; onBeforeMount &gt; onReady &gt; onMounted</p><hr><h3 id="css基础布局">css基础布局</h3><h4 id="盒子模型（div-view）布局">盒子模型（div-&gt;view）布局</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使容器成为一个弹性盒子，子元素可以根据规则进行动态排列</span><br><br><span class="hljs-attr">display</span>:flex<br></code></pre></td></tr></table></figure><p>父容器属性</p><table><thead><tr><th>属性</th><th>功能</th><th>值</th></tr></thead><tbody><tr><td>flex-direction</td><td>设置子元素的排列方向</td><td><code>row</code><br/><code>column</code><br/></td></tr><tr><td>justify-content</td><td>设置子元素在主轴（flex-direction指定的方向上的对齐方式</td><td><code>flex-start</code>（默认，左对齐）<br/><code>center</code>（居中）<br/><code>flex-end</code>（右对齐）<br/><code>space--between</code>（两端对齐、元素之间均匀分布）<br/><code>space-around</code>（元素之间均匀分布，且有外边距）</td></tr><tr><td>align-items</td><td>设置子元素在交叉轴上的对齐方式</td><td><code>strech</code>（默认，拉伸填充）<br/><code>flex-start</code>（顶部对齐）<br/><code>center</code>（垂直居中）<br/><code>flex-end</code>（底部对齐）<br/><code>baseline</code>（文字基线对齐）</td></tr><tr><td>gap</td><td>设置子元素之间的间距（水平和垂直要间距统一）</td><td>任意长度值（如10px）</td></tr><tr><td>flex-wrap</td><td>设置子元素是否换行排列</td><td><code>nowrap</code>（默认，不换行）<br/><code>wrap</code>（自动换行）<br/><code>wrap-reverse</code>（换行，反向排列）</td></tr><tr><td>align-content</td><td>在多行布局下，设置多行之间的对齐方式（只适用于flex-wrap换行的情况）</td><td><code>stretch</code> (默认，均匀拉伸)<br/> <code>flex-start</code> (顶部对齐)<br/> <code>center</code> (居中)<br/> <code>flex-end</code> (底部对齐)<br/> <code>space-between</code> (两端对齐)<br/> <code>space-around</code> (均匀分布)</td></tr></tbody></table><p>子元素属性</p><table><thead><tr><th>属性</th><th>功能</th><th>值</th></tr></thead><tbody><tr><td><strong><code>flex</code></strong></td><td>定义子元素的伸缩比例（占据空间的灵活性）。</td><td><code>auto</code> (自动)  <code>1</code> (等比例伸缩)  <code>0</code> (不伸缩)  也可以用 <code>flex-grow flex-shrink flex-basis</code> 定义</td></tr><tr><td><strong><code>align-self</code></strong></td><td>设置单个子元素在交叉轴上的对齐方式（覆盖 <code>align-items</code> 的设置）。</td><td><code>auto</code> (继承父级)  <code>flex-start</code> (顶部对齐)  <code>center</code> (垂直居中)  <code>flex-end</code> (底部对齐)</td></tr><tr><td><strong><code>order</code></strong></td><td>设置子元素的排列顺序，值越小越靠前，默认为 <code>0</code>。</td><td>任意整数值，比如 <code>-1</code> 或 <code>2</code>。</td></tr></tbody></table><hr><h3 id="其余前端知识点">其余前端知识点</h3><hr><h4 id="箭头函数（Arrow-Function）">箭头函数（Arrow Function）</h4><p>箭头函数是 JavaScript 中的一种简写函数形式。它引入与 ES6 ，用来简化函数的声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">functionname</span> = (<span class="hljs-params">parameters</span>) =&gt; &#123;expressions&#125;;<br></code></pre></td></tr></table></figure><ul><li>如果函数体只有一行代码，且返回值可以直接省略<code>return</code>关键字和大括号</li><li>如果有多个参数，则用逗号分隔，参数周围不用括号时，仅限单个参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 普通函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a,b</span>) &#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><br><span class="hljs-comment">// 箭头函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a,b</span>) =&gt; a+b;<br><br><span class="hljs-comment">// 只有一个参数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">square</span> = x =&gt; x*x;<br><br><span class="hljs-comment">// 函数体有多行代码</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">multiply</span> = (<span class="hljs-params">a,b</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> result = a * b;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="回调函数">回调函数</h4><blockquote><p>这里只是简单对回调函数进行一个介绍，具体的讲解请点击下面的链接</p><p><a href="">关于回调函数以及异步编程</a></p></blockquote><ul><li><strong>回调函数</strong>是一个<code>作为参数传递给其他函数</code>的函数。<ul><li>其实回调函数就是普通函数，只是它是作为一个参数使用的函数</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greeting</span>(<span class="hljs-params">name</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>);<br>&#125;<br><br><span class="hljs-comment">// 使用回调函数</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processUserInput</span>(<span class="hljs-params">callback</span>) &#123; <br>    <span class="hljs-comment">// 这里的方式跟函数定义传参一样，名字不一定一样，只是逻辑</span><br>    <span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;lisi&quot;</span>;<br>    <span class="hljs-title function_">callback</span>(name);  <br>&#125;<br><br><span class="hljs-comment">// 记住定义函数要使用，否则只是单纯的定义函数</span><br><br><span class="hljs-comment">// 使用函数processUserInput,并且传参（回调）</span><br><span class="hljs-title function_">processUserInput</span>(greeting); <br><br><span class="hljs-comment">// 输出: Hello,lisi!</span><br></code></pre></td></tr></table></figure><h5 id="为什么要使用回调函数？">为什么要使用回调函数？</h5><p><code>这里的内容我参考了很多资料，但是仍然有一些不足，但是核心思想差别不大，这里的内容可以帮助你理解回调</code></p><ol><li><p><strong>回调函数通常用于需要异步处理、延迟处理或者动态处理的场景。</strong></p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在js中，异步操作（如定时器、API请求）需要依赖回调函数来处理操作完成后的结果</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello after 2 seconds!&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// setTimeout 是一个异步函数</span><br><span class="hljs-built_in">setTimeout</span>(sayHello,<span class="hljs-number">2000</span>);<br><br><span class="hljs-comment">// 也就是在2s后执行sayHello</span><br></code></pre></td></tr></table></figure></li><li><p>在某些场景下，会希望 <strong>某些代码只在特定事件或任务完成后才执行</strong>，这时回调函数就非常有用。</p><p>例如：异步操作的结果不会立即返回，而回调函数可以确保结果完成后再继续执行</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模拟网络请求</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fecthData</span>(<span class="hljs-params">callback</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Data fetched&quot;</span>);<br>        <span class="hljs-title function_">callback</span>();<br>    &#125;,<span class="hljs-number">2000</span>);<br>&#125;<br><br><span class="hljs-comment">// 回调函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Processing data...&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 注意这里的执行顺序：fetchData -&gt; processData</span><br><span class="hljs-title function_">fetchData</span>(processData);<br></code></pre></td></tr></table></figure></li><li><p><strong>在 Js 等语言中，很多操作是异步的（如定时器、事件监听、网络请求等）。回调函数是处理异步任务的核心机制，它能让你在任务完成后执行下一步操作，而不会阻塞主线程。</strong></p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">step1</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Step 1 completed&quot;</span>);<br>  <span class="hljs-title function_">callback</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">step2</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Step 2 completed&quot;</span>);<br>  <span class="hljs-title function_">callback</span>();<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">step3</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Step 3 completed&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 按顺序执行多个异步任务</span><br><span class="hljs-title function_">step1</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">step2</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">step3</span>();<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>是不是看起来很简单？目前的回调函数是“独立”的，他们之间并不存在任何关系，如果我的前一个函数需要后一个函数的返回参数呢？</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">场景：</span><br><span class="hljs-comment"> 1.用户登录</span><br><span class="hljs-comment"> 2.获取用户数据</span><br><span class="hljs-comment"> 3.查询用户的朋友列表</span><br><span class="hljs-comment"> 4.发送消息给每个朋友</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">loginUser</span>(<span class="hljs-params">username,password,callback</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`User <span class="hljs-subst">$&#123;username&#125;</span> logged in`</span>);<br>       <span class="hljs-title function_">callback</span>(&#123;<span class="hljs-attr">userId</span>:<span class="hljs-number">1</span> ,<span class="hljs-attr">username</span>: username&#125;); <span class="hljs-comment">// 返回用户信息</span><br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUserData</span>(<span class="hljs-params">userId, callback</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Fetched data for user <span class="hljs-subst">$&#123;userId&#125;</span>`</span>);<br>    <span class="hljs-title function_">callback</span>(&#123;<span class="hljs-attr">userId</span>:userId, <span class="hljs-attr">friends</span>:[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]&#125;); <span class="hljs-comment">// 返回用户数据</span><br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchFriends</span>(<span class="hljs-params">friendsIds,callback</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Fetched friends for user ：<span class="hljs-subst">$&#123;friendsIds.join(<span class="hljs-string">&quot;,&quot;</span>)&#125;</span>`</span>)；<br>        <span class="hljs-title function_">callback</span>(friendIds.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> (&#123; <span class="hljs-attr">friendId</span>: id, <span class="hljs-attr">name</span>: <span class="hljs-string">`Friend <span class="hljs-subst">$&#123;id&#125;</span>`</span>&#125;)));<br>    &#125;, <span class="hljs-number">1000</span>);<span class="hljs-comment">// 返回朋友列表</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params">friend,callback</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Message sent to <span class="hljs-subst">$&#123;friend.name&#125;</span>`</span>);<br>       <span class="hljs-title function_">callback</span>();<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-comment">// 开始嵌套的回调地狱</span><br><span class="hljs-title function_">loginUser</span>(<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-string">&quot;password123&quot;</span>, <span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">fetchUserData</span>(user.<span class="hljs-property">userId</span>, <span class="hljs-function"><span class="hljs-params">userData</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">fetchFriends</span>(userData.<span class="hljs-property">friends</span>, <span class="hljs-function"><span class="hljs-params">fiends</span> =&gt;</span> &#123;<br>            friends.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">friend</span> =&gt;</span> &#123;<br>                <span class="hljs-title function_">sendMessage</span>(friend, <span class="hljs-function">() =&gt;</span> &#123;<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Done processing #&#123;friend.name&#125;`</span>);<br>                &#125;);<br>            &#125;);<br>        &#125;);<br>    &#125;);<br>&#125;);<br><br><span class="hljs-comment">/* 输出结果：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            User lisi logged in</span><br><span class="hljs-comment">            Fetched data for user 1</span><br><span class="hljs-comment">            Fetched friends for user: 2, 3, 4</span><br><span class="hljs-comment">            Message sent to Friend 2</span><br><span class="hljs-comment">            Done processing Friend 2</span><br><span class="hljs-comment">            Message sent to Friend 3</span><br><span class="hljs-comment">            Done processing Friend 3</span><br><span class="hljs-comment">            Message sent to Friend 4</span><br><span class="hljs-comment">            Done processing Friend 4</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">接下来让我们来看一下这个回调地狱：</span><br><span class="hljs-comment">首先我们先看（用户）场景：就是一个用户登录，然后要发送消息给用户的朋友。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    但是对于我们来说（程序员）场景：</span><br><span class="hljs-comment">    验证登录信息 -&gt; 获取用户（关键词）信息 -&gt; （根据关键词）寻找用户朋友（列表）-&gt; </span><br><span class="hljs-comment">（根据朋友列表）发送信息</span><br><span class="hljs-comment">（为了更直观看出嵌套逻辑，以及以后在开发过程中调试代码，加上了console.log）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">可以看到这里的每一步都依靠前一步的结果：</span><br><span class="hljs-comment">loginUser：用户登录后返回用户信息（如 user.userId）。</span><br><span class="hljs-comment">        fetchUserData：必须使用 user.userId 来获取用户的具体数据（如 friends 列表）。</span><br><span class="hljs-comment">        fetchFriends：需要根据用户的数据（friends 列表）查询用户的朋友信息。</span><br><span class="hljs-comment">        sendMessage：必须有朋友的信息，才能给每个朋友发送消息。</span><br><span class="hljs-comment">--------------------------------------------------------------------------------</span><br><span class="hljs-comment">如果觉得很难理解，可以这么看：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">上面这四个函数均是我们自己实现的：我们需要先登录确定用户身份后才能将用户的关键词ID获取到，</span><br><span class="hljs-comment">获取到ID后我们才能用用户的ID去数据库中寻找用户的friend列表，有了friend列表我们才能获取到</span><br><span class="hljs-comment">每个人的ID和信息（ID是辨别人的key），获取到每个人的ID我们才能发送信息，这是一整个流程是必</span><br><span class="hljs-comment">须这么实现的。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>​因为逻辑就是这样的，嵌套的逻辑显然在某些情况下很难操作，所以我们可以采用几种异步操作来解决。（这里解决方案在后面的网络基础知识中解决）</p><ul><li><strong>回调地狱</strong>：（在处理多个异步操作时）当多个异步操作需要按顺序执行，且每个操作的结果都是下一个操作的输入时，代码往往会变成多层嵌套的回调函数，导致代码难以阅读和维护。<ul><li>代码嵌套严重</li><li>难以维护</li><li>错处处理苦难</li></ul></li><li><font color=red>回调函数在其他编程语言中如 C , Cpp , Java 等中均有体现，只是展示样式不同，例如 c 等语言中是利用函数指针来实现回调函数</font></li></ul></li></ol><h5 id="回调函数的含义和用途：">回调函数的含义和用途：</h5><ul><li>控制执行顺序</li><li>提高代码复用性和灵活性</li><li>解耦和模块化</li><li>异步编程的核心</li></ul><hr><h4 id="DOM">DOM</h4><p>其实我们可以把DOM理解成一种抽象出来的语法树结构，它是 html 或者 XML 被浏览器解析生成的一种树形结构。</p><blockquote><p><strong>1.DOM的定义</strong></p><ul><li>DOM（Document Object Model），文档对象模型，是浏览器解析 HTML 或 XML 文件后生成的一种树形数据结构</li><li><strong>核心思想</strong>：DOM提供了对文档的抽象化表示和操作方法</li></ul><p><strong>2. DOM Core</strong></p><ul><li>Node：DOM树的基本单元，每个元素、属性、文本都是一个Node</li><li>Document：表示整个文档（DOM树的根）</li><li>ELement：表示 HTML 或 XML 的元素</li><li>Attr：表示元素的属性</li><li>Text：表示文本内容</li></ul><p><strong>3.DOM的用途</strong></p><ul><li>动态更新内容</li><li>实现交互式页面</li><li>数据驱动的动态加载</li><li>动态样式与动画</li></ul><p><strong>4.DOM的局限性</strong></p><ol><li>性能问题：<ul><li>DOM操作的频繁修改可能导致性能下降（如页面的重排与重绘）</li><li>解决办法：使用虚拟DOM（如React、Vue的实现）</li></ul></li><li>复杂性：<ul><li>直接操作DOM树时，代码复杂且难以维护</li><li>使用前端框架（Vue、React）可以简化DOM操作</li></ul></li></ol></blockquote><hr><h4 id="一些常用的循环操作">一些常用的循环操作</h4><h5 id="v-for">v-for</h5><p><code>v-for</code> 是 Vue （Uniapp 基于 Vue 开发）的模版指令，专用于模版中遍历数组或对象，生成一组动态元素。</p><h6 id="特点：">特点：</h6><ul><li><strong>直接在模版中使用</strong>，用于渲染列表</li><li>语法类似于 <code>for</code> 循环，但作用于模版</li><li>需要绑定 <code>key</code> 属性以优化性能（避免重复渲染）</li><li>适合用来动态生成DOM结构</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;view v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(item,index) in list&quot;</span> :key = index&gt;<br>    索引：&#123;&#123;index&#125;&#125;，值：&#123;&#123;item&#125;&#125;<br>&lt;/view&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value,key) in object&quot;</span> <span class="hljs-attr">:key</span> = <span class="hljs-string">key</span>&gt;</span></span><br><span class="language-xml">    键：&#123;&#123;key&#125;&#125;，值：&#123;&#123;value&#125;&#125;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li><code>v-for</code> 是模版专用工具，不能在逻辑代码中使用</li><li>在使用时应避免与 <code>forEach</code> 和 <code>map</code> 混淆</li></ul><h5 id="forEach">forEach</h5><p><code>forEach</code>是 Javascript 数组对象的方法，用于遍历数组。它的主要功能是对数组的每一项执行指定的操作。</p><h6 id="特点：-2">特点：</h6><ul><li>不会返回数组，只是对数组中的每一项执行回调操作</li><li>回调函数可以访问当前元素、索引和数组本身</li><li>更适合用来当做副作用操作，比如更新全局状态、调用接口等</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item,index</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`索引: <span class="hljs-subst">$&#123;index&#125;</span>,值: <span class="hljs-subst">$&#123;item&#125;</span>`</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h6 id="在-Uniapp-中的使用：">在 Uniapp 中的使用：</h6><p><code>forEach</code> 通常用在逻辑代码中，比如处理数据或调用接口，而不是直接用于模版中渲染。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">onLoad</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br>    numbers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">num,index</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`第 <span class="hljs-subst">$&#123;index + <span class="hljs-number">1</span>&#125;</span> 个数是: <span class="hljs-subst">$&#123;num&#125;</span>`</span>);<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="map">map</h5><p><code>map</code> 是 Javascript 数组的另一种方法，它的主要功能是对数组中的每一项应用回调函数，并返回一个新的数组</p><h6 id="特点：-3">特点：</h6><ul><li><strong>返回一个新数组</strong>，不会修改原数组</li><li>新数组中的值由回调函数的返回值决定</li><li>更适合用来对数组进行转换，比如生成新的结构或加工数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> newArr = arr.<span class="hljs-title function_">map</span>(item = &gt; item *<span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr); <span class="hljs-comment">// 输出[2,4,6,8]</span><br></code></pre></td></tr></table></figure><h6 id="在-Uniapp-中的使用">在 Uniapp 中的使用</h6><p>可以在逻辑代码中使用 <code>map</code> 来加工数据，生成适合模版渲染的结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">onLoad</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> products = [<br>        &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">10</span>&#125;,<br>        &#123;name; <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">20</span>&#125;,<br>    ];<br>    <br>    <span class="hljs-keyword">let</span> formattedProducts = products.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">product</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            ...product,<br>            <span class="hljs-attr">priceText</span>:<span class="hljs-string">`￥ <span class="hljs-subst">$&#123;product.price&#125;</span>`</span>, <span class="hljs-comment">// 添加新的字段</span><br>        &#125;;<br>    &#125;);<br>    <br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(formattedProducts);<br>&#125;<br><br><span class="hljs-comment">// 注意 map 是 Javascript 的逻辑操作，与模版语法 v-for 不同， map 不直接参与模版渲染</span><br></code></pre></td></tr></table></figure><hr><h3 id="网络基础知识">网络基础知识</h3><h4 id="异步请求">异步请求</h4><p><code>异步请求</code>是指在程序运行过程中，发送请求的代码不会阻塞后续的代码执行，而是会在请求完成后通过回调函数、Promise或事件来处理结果。这种机制让程序可以一边发送请求一边做其他事情，从而提高运行效率和用户体验。</p><h5 id="异步同步化：">异步同步化：</h5><p>异步同步化是一种解决 “回调地狱” 的方法很常见：</p><h6 id="1-回调函数（Callback">1.回调函数（Callback)</h6><p>当异步操作完成后，通过回调函数来处理结果。</p><h6 id="2-Promise">2.Promise</h6><p><code>Promise</code>是一种更优雅的方式来处理异步操作，解决了回调函数嵌套过深（回调地狱）的问题</p><h6 id="3-async-await">3.async/await</h6><p><code>async/await</code>是基于Promise的语法糖，能让异步代码看起来像同步代码</p><hr><h2 id="Uniapp学习">Uniapp学习</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>上面的代码就是我们一般的基础格式：（当然也可以按照自己的习惯，将 template 部分和 js 语法部分位置转换等等，这些都是按照自己的习惯来选择的，这里我依照我常用的方式来表示）</p><p><font color=red>这个部分大家理解一下就好，毕竟如果上来直接从内容开始实战好像也行！！！</font></p><blockquote><ul><li>template：这个部分是基础的 html 的内容，就是对页面的内容进行基础渲染的部分，但是学会 html 的都知道，单纯的html 看起来的效果是非常单一的，因为他只有一些最基本的“框架&quot;，也可以把它理解成基本的线条，对于一幅完美的画面来说，光有单一的线条是远远不够的，我们需要有一些色彩。</li><li>style：这个部分就是我们刚刚提到的色彩部分，各位从小画过手抄报吗？如果是单一的黑色图画和文字组成的手抄报很容易会被老师打回重做，这个时候我们便会苦苦央求家长买一盒彩笔上色，在这里，我们只需要在 style 里面写上我们需要的色彩，不需要央求谁去花费买颜料，这也就是 style 部分的基本功能。</li><li>script：其实对于一个单一的页面（静态）来说，上面的两个部分已经足够去完成一幅美丽的画面，可以完成一个静态页面，但是我们大部分的页面是需要有交互的，并不只是让用户去看，特别是app方面，我们更注重的是用户的体验，此时，script 部分的作用就可以体现出来，它是负责完成一些动作，接受并且对于用户的某些行为作出反应的一个板块，我们可以让用户点击、滑动、拖动等等，增强页面和用户之间的互动性，增强用户的体验感，否则app有什么作用呢？</li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>uniapp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Springboot + Scrapy + Vue的信息快检索平台</title>
    <link href="/DataWeb/"/>
    <url>/DataWeb/</url>
    
    <content type="html"><![CDATA[<p><code>本次博客内容先瞻：</code></p><span class="label label-primary">text</span>本次博客，我们要实现利用 Scrapy 框架对网站数据进行爬取后存储到MySQL数据库中，然后使用 Vue 写一个Web网站，最后利用 Springboot 框架编写后端接口，将数据库的内容渲染到网站，实现一个简单的信息快检索平台。]]></content>
    
    
    
    <tags>
      
      <tag>Springboot</tag>
      
      <tag>Vue</tag>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Compilers</title>
    <link href="/Compeilers/"/>
    <url>/Compeilers/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    
    <tags>
      
      <tag>Compilers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Organization</title>
    <link href="/ComputerOrganization/"/>
    <url>/ComputerOrganization/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><div class="note note-warning">            <p>本文是介绍计算机组成原理，覆盖408考点，部分借鉴国外书籍，主要以王道408为依托。</p>          </div><h2 id="第一章-概论"><a href="#第一章-概论" class="headerlink" title="第一章 概论"></a>第一章 概论</h2><p><img src="/img/C-O/1.1.png"></p><blockquote><ol><li><p>计算机由哪几部分组成？以哪部分为核心？</p></li><li><p>主频高的CPU一定比主频低的CPU快吗？为什么？</p></li><li><p>翻译程序、汇编程序、编译程序、解释程序有什么区别？各自的特性是什么？</p></li><li><p>不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？</p></li></ol></blockquote><h3 id="1-1-计算机发展历程"><a href="#1-1-计算机发展历程" class="headerlink" title="1.1 计算机发展历程"></a>1.1 计算机发展历程</h3><h4 id="1-1-1-计算机的软硬件的概念"><a href="#1-1-1-计算机的软硬件的概念" class="headerlink" title="1.1.1 计算机的软硬件的概念"></a>1.1.1 计算机的软硬件的概念</h4><p>计算机系统由“硬件”和“软件”两大部分组成。</p><p>​硬件：计算机的实体部分，它由看得见摸得着的各种电子元器件，各类光、电、机设备的实物组成，如主机，外部设备等。</p><p>​软件：它看不见摸不着，由人们事先编制的具有各类特殊功能的程序组成。</p><h4 id="1-1-2计算机的发展"><a href="#1-1-2计算机的发展" class="headerlink" title="1.1.2计算机的发展"></a>1.1.2计算机的发展</h4><table><thead><tr><th>发展阶段</th><th>时间</th><th>逻辑元件</th><th>速度（次&#x2F;秒）</th></tr></thead><tbody><tr><td>一代</td><td>1946 - 1957</td><td>电子管</td><td>几千~几万</td></tr><tr><td>二代</td><td>1958 - 1964</td><td>晶体管</td><td>几万~几十万</td></tr><tr><td>三代</td><td>1964 - 1971</td><td>中小规模集成电路</td><td>几十万~几百万</td></tr><tr><td>四代</td><td>1972 - 今</td><td>大规模和超大规模集成电路</td><td>上千万~万亿</td></tr></tbody></table><p><strong>摩尔定律：</strong>集成电路上的晶体管数量每18个月就会翻一番，所以每18个月计算机的处理效率就会提高一倍。</p><blockquote><p>晶体管之父：肖克利（1956年诺贝尔物理学奖得主）</p><p>1957年，“八叛徒”创立了仙童半导体</p><p>1959年，仙童半导体发明了“集成电路”</p><p>1968年，摩尔离开仙童，创立intel</p><p>1969年，仙童销售部负责人桑德斯离开仙童，创立AMD</p></blockquote><h4 id="1-1-3-计算机的分类和发展方向"><a href="#1-1-3-计算机的分类和发展方向" class="headerlink" title="1.1.3 计算机的分类和发展方向"></a>1.1.3 计算机的分类和发展方向</h4><ul><li>电子模拟计算机和电子数字计算机<ul><li>电子数字计算机按用途分为2类：专用计算机、通用计算机<ul><li>通用计算机：巨型机、大型机、中型机、小型机、微型机和单片机6类</li></ul></li><li>按照指令和数据流分为：<ul><li>单指令流和单数据流系统（SISD），即传统的冯·诺依曼体系结构</li><li>单指令流和多数据流系统（SIMD），包括阵列处理器和向量处理器系统</li><li>多指令流和单数据流系统（MISD），这种计算机实际上不存在</li><li>多指令流和多数据流系统（MIMD），包括多处理器和计算机系统</li></ul></li></ul></li></ul><h3 id="1-2-计算机系统的层次结构"><a href="#1-2-计算机系统的层次结构" class="headerlink" title="1.2 计算机系统的层次结构"></a>1.2 计算机系统的层次结构</h3><p><strong>五个层级 三种语言 两种程序</strong></p><p><img src="/img/C-O/1.2.1.png"></p><h4 id="1-2-1-计算机系统的组成"><a href="#1-2-1-计算机系统的组成" class="headerlink" title="1.2.1 计算机系统的组成"></a>1.2.1 计算机系统的组成</h4><p>计算机系统由硬件系统和软件系统共同构建起来</p><h4 id="1-2-2-计算机硬件的基本构成"><a href="#1-2-2-计算机硬件的基本构成" class="headerlink" title="1.2.2 计算机硬件的基本构成"></a>1.2.2 计算机硬件的基本构成</h4><h5 id="1-早期的冯·诺依曼机"><a href="#1-早期的冯·诺依曼机" class="headerlink" title="1.早期的冯·诺依曼机"></a>1.早期的冯·诺依曼机</h5><blockquote><p>美籍匈牙利科学家冯·诺依曼最先提出“程序存储”的思想，并成功将其运用在计算机的设计之中，根据这一原理制造的计算机被称为冯·诺依曼结构计算机。由于他对现代计算机技术的突出贡献，因此冯·诺依曼又被称为“现代计算机之父”。</p><p><font color=blue>什么是存储程序原理？按此原理，计算机应具有哪几大功能？</font></p><p><font color=red>“程序存储”</font>：指令以代码的形式事先输入到计算机的主存储器中，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他程序，直至程序执行结束，即<font color="red">按地址访问并顺序执行指令</font></p><p>计算机按照此原理应具有5大功能：数据传送功能、数据存储功能、数据处理功能、操作控制功能、操作判断功能</p></blockquote><ul><li>冯·诺依曼体系结构特点<ol><li>计算机硬件系统由五大部件构成（存储器，运算器，控制器，输入设备，输出设备）</li><li>指令和数据以同等地位存于存储器，可按地址寻访</li><li>指令和数据用二进制表示</li><li>指令由操作码和地址码组成</li><li>存储程序</li><li>以运算器为中心</li></ol></li></ul><blockquote><p>早期的冯·诺依曼机以运算器为中心，且是单处理机，最根本的特征是采用“存储程序”原理，基本工作方式是<strong>控制流驱动方式</strong></p></blockquote><p><img src="/img/C-O/1.2.2.png"></p><h5 id="2-现代计算机的组织结构"><a href="#2-现代计算机的组织结构" class="headerlink" title="2.现代计算机的组织结构"></a>2.现代计算机的组织结构</h5><p><img src="/img/C-O/1.2.3.png"></p><h5 id="3-计算机的功能部件"><a href="#3-计算机的功能部件" class="headerlink" title="3.计算机的功能部件"></a>3.计算机的功能部件</h5><p>主机：主存、运算器、控制器</p><p><img src="/img/C-O/1.2.4.png"></p><p>五大部分：</p><ol><li><p>输入设备：是指将外部信息以计算机能读懂的方式输入进来，如键盘，鼠标等</p></li><li><p>输出设备：就是将计算机处理的信息以人所能接受的方式输出出来，比如显示屏，打印机</p></li><li><p>存储器，存储器主要分为<strong>主存储器</strong>（内存储器，CPU能直接访问）和<strong>辅助存储器</strong>（外存储器，协助主存储器记忆更多的信息，辅助存储器的信息需要导入到主存储器中，才能被CPU访问。</p><ul><li><strong>主存储器</strong>的工作方式是<font color=red>按存储单元的地址进行存取</font>，这种存取方式称为<strong>按地址存取方式</strong>（相联存储器既可以按照<strong>地址寻址</strong>，又可以按照<strong>内容寻址</strong>，为了与传统存储器区别，又称为<strong>内容寻址的存储器</strong>。</li><li>主存储器是由地址寄存器（MAR），数据寄存器（MDR），存储体，时序控制逻辑，地址寄存器存放访存地址，经过地址译码后找到所选的存储单元。数据寄存器，是存储器与其他部件的中介，用于暂存要从存储器读或写的信息。时序控制逻辑用于产生存储器操作所需的各种时序信号。在现代CPU中，MAR和MDR是在CPU中的。</li></ul><p> <img src="/img/C-O/1.2.5.png"></p></li><li><p>运算器：是计算机的运算单元，用于算数运算和逻辑运算，运算器的核心单元是算术逻辑单元（ALU）</p><p> <img src="/img/C-O/1.2.6.png"></p></li><li><p>控制器：是计算机的指挥中心，有其指挥各部件自动协调的进行工作，现代计算机将运算器和控制器集成到一个芯片上，合成中央处理器，简称CPU。有程序计数器（PC）、指令寄存器（IR）和控制单元（CU）</p><p> <img src="/img/C-O/1.2.7.png"></p></li></ol><p><font color=bule>一般将运算器和控制器集成到同一个芯片上，称为<strong>中央处理器（CPU）</strong>。<strong>CPU</strong>和<strong>主存储器</strong>共同构成主机，而除主机外的其他硬件装置（外存，I&#x2F;O设备等）统称为外部设备，即<strong>外设</strong>。</font></p><p>CPU和主存之间通过一组<strong>总线</strong>相连，总线中有<strong>地址、控制和数据3组信号线</strong>。MAR中的地址信息会直接送到地址线上，用于指向读&#x2F;写操作的主存存储单元；控制线中有读&#x2F;写信号线，指出数据是从CPU写入主存还是从主存读出到CPU，根据是读操作还是写操作来控制将MDR中的数据直接送到数据线上还是将数据线上的数据接收到MDR中。</p><h3 id="1-3-计算机软件的分类"><a href="#1-3-计算机软件的分类" class="headerlink" title="1.3 计算机软件的分类"></a>1.3 计算机软件的分类</h3><p>计算机软件，一般分为系统软件和应用软件</p><ul><li>系统软件包括 操作系统、数据库管理系统、语言处理系统（比如编译器）、分布式软件系统、网络软件系统、标准库系统、服务性系统（比特连接程序）</li><li>应用软件包括各种科学计算类程序，工程设计类程序，数据统计与处理程序</li></ul><p>注意：数据库管理系统和数据库系统是有区别的。数据库管理系统是系统软件。而数据库系统一般是由数据库，数据库管理系统，数据库管理员和应用系统构成。所以只能说它里面有系统软件，但并不能说它为系统软件。</p><p>2.三个级别的语言</p><ul><li>机器语言。又称二进制代码语言，需要编程人员记忆每条指令的二进制编码。<strong>机器语言是计算机唯一可以直接识别和执行的语言。</strong></li><li>汇编语言。汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编语言编辑的程序，必须经过一个称为汇编程序的系统软件的翻译，将其转换为计算机的机器语言后，才能在计算机的硬件系统上执行。</li><li>高级语言。高级语言(如C、C++、Java等)是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。</li><li>由高级语言转换到汇编语言的过程叫做<strong>编译</strong>，由汇编语言转换到机器语言的过程叫做<strong>汇编</strong>，边翻译边执行的叫做<strong>解析</strong>。</li></ul><p>机器语言是<strong>唯一</strong>可以控制cpu的语言，因为它的符号不利于人识别和书写，为了方便理解和记忆，将机器语言换一些通俗易懂的符号，这就变成了汇编语言。一般来说在在编译器中高级语言先转换为汇编在转换为机器语言，也有直接转换为机器语言的情况。</p><blockquote><p><font color=green>机器语言是计算机唯一可以直接执行的语言</font>，汇编语言用助记符编写，以便记忆。而正则语言是编译原理中符合正则文法的语言。</p><p>解释程序的特点是翻译一句执行一句，边翻译边执行：由高级语言转化为汇编语言的过程叫编译，把汇编语言翻译成机器语言的过程叫汇编。</p></blockquote><p>IR存放当下欲执行的指令；PC存放下一条指令的地址；</p><p>MAR存放欲访问的存储单元地址；MDR存放从存储单元取来的数据</p><p>地址译码器是主存的构成部分，不属于CPU；地址寄存器虽然一般属于主存，但是现代计算机中绝大多数CPU内集成了地址寄存器</p><p>关于CPU存取速度的比较：寄存器（CPU内部）&gt; Cache（高速的SRAM）&gt; 内存（SDRAM）</p><h3 id="1-4-计算机的性能指标"><a href="#1-4-计算机的性能指标" class="headerlink" title="1.4 计算机的性能指标"></a>1.4 计算机的性能指标</h3><p><img src="/img/C-O/1.3.1.png"></p><p><code>周期：1次需要多少s，频率：1s能完成多少次</code></p><p><strong>1.机器字长</strong>：</p><p>计算机的位数（机器字长），表示计算机一次整数运算（即定点整数运算）所能处理的二进制数据位数。计算机字长通常选定为（8位），通常是2,4,8倍。不同的计算机，字节可能不同</p><blockquote><p><font color=red>机器字长，指令字长，存储字长的区别和联系</font></p><ul><li>机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度</li><li>指令字长：一个指令字中包含的二进制代码的位数。</li><li><strong>存储字长</strong>：一个存储单元存储的二进制代码的长度。<strong>等于MDR的位数</strong>，他们都必须是字节的整数倍</li><li><strong>数据字长：数据总线一次能传送信息的位数，</strong>它可以不等于MDR的位数。</li></ul><p>指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令，因此取指周期为机器周期的2倍；若指令字长等于存储字长，则取指周期等于机器周期。</p><p>早期的计算机存储字长一般和机器的指令字长与数据字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍。</p><p>请注意64位操作系统是指特别为64位架构的计算机而设计的操作系统，它能够利用64位处理器的优势。但64位机器既可以使用64位操作系统，又可以使用32位操作系统。而32位处理器是无法使用64位操作系统的。</p></blockquote><p><strong>2.数据通路带宽</strong></p><p>数据总线一次所能传送信息的位数</p><p><strong>3.主存容量</strong></p><p>MAR的位数反映存储单元的个数，如MAR为16位，表示存储单元为$$2^{16} &#x3D; 64k$$;若MDR为32位，则存储容量为$$2^{16}*32 $$</p><p><strong>4.运算速度</strong></p><blockquote><p>吞吐量：指系统在单位时间内处理的请求；从用户观点看，它是评价计算机系统性能的综合参数</p><p>响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结构的等待时间</p></blockquote><blockquote><p>CPU时钟周期：通常为节拍脉冲或T周期，即主频的倒数，它是CPU中最小的时间单位，每个动作至少需要1个时钟周期。</p><p>主频（CPU时钟频率）：机器内部主时钟的频率，是衡量机器速度的重要参数。</p><ul><li>CPU周期又称为机器周期，由多个时钟周期组成</li><li>指令周期&gt;CPU周期&gt;时钟周期</li></ul></blockquote><blockquote><p><font color = red>CPI（Clock cycle Per Instruction)：即执行一条指令所需的时钟周期数</font></p></blockquote><blockquote><p>CPU执行时间，指运行一个程序所花费的时间</p><p><strong>CPU执行时间 &#x3D; CPU时钟周期&#x2F;主频 &#x3D; （指令条数 * CPI)&#x2F;主频</strong></p><p><strong>CPU的性能</strong>主要取决于三个因素：<strong>主频</strong>、<strong>CPI</strong>、<strong>指令条数</strong></p></blockquote><blockquote><p>IPS(Instructions Per Second) &#x3D;主频&#x2F;平均CPI，每秒执行多少指令</p><p>MIPS(Million Instructions Per Second)&#x3D;即每秒执行多少百万条指令。</p><p>MFLOPS(Mega Floating-point Operations Per Second)&#x3D;浮点操作次数&#x2F;(执行时间x106),即每秒执行多少百万次浮点运算。</p><p>GFLOPS(Giga Floating-point Operations Per Second)&#x3D;浮点操作次数&#x2F;(执行时间x109)，即每秒执行多少十亿次浮点运算。</p><p>TFLOPS(Tera Floating-point Operations Per Second)&#x3D;浮点操作次数&#x2F;(执行时间x1012)，即每秒执行多少万亿次浮点运算</p></blockquote><h3 id="背诵总结："><a href="#背诵总结：" class="headerlink" title="背诵总结："></a>背诵总结：</h3><div class="note note-danger">            <ul><li>冯·诺依曼提出存储程序</li><li>冯·诺依曼结构特点<ol><li>存储程序工作方式</li><li>计算机由五大部件组成（运算器，控制器，存储器，输入设备，输出设备）</li><li>指令和数据以二进制代码同等地位存储在存储器中，并按照地址访问，<code>指令由操作码和地址码组成</code></li><li>指令按照顺序存放执行</li><li>冯·诺依曼计算机以运算器为中心，现代计算机以存储器为中心</li><li>单处理机</li><li>工作方式是控制流驱动方式</li></ol></li><li>机器语言由二进制表示，是计算机唯一可以直接识别和执行的语言</li><li>翻译程序<ul><li>汇编语言：汇编语言源程序 —— 机器语言目标程序</li><li>编译语言：高级语言源程序 —— 汇编语言源程序 —— 机器语言目标程序</li><li>解释程序：高级语言逐条翻译成机器指令并立刻执行</li></ul></li></ul><hr><ul><li>计算机 &#x3D; 主机 + 输入&#x2F;输出设备</li><li>主机 &#x3D; CPU + 主存</li><li>CPU &#x3D; 控制器 + 运算器</li></ul><hr><ul><li>机器字长：CPU内部用于整数运算的数据通路的带宽 &#x3D; 运算器一次性能处理的二进制长度 &#x3D; 通用寄存器的宽度（位数）</li><li>指令字长：一个指令包含的二进制代码位数</li><li>存储字长：一个存储单元存储的二进制代码长度</li><li>数据通路带宽：数据总线一次性能传送信息的长度</li><li>总线带宽：总线的带宽容量 * 总线工作频率</li><li>吞吐量：单位时间内处理请求的个数</li><li>响应时间：CPU时间 + 等待时间</li><li>主频：机器内部每秒的时钟周期数</li><li>时钟周期：主频的倒数</li><li>CPI：执行一条指令所需的时钟周期数</li></ul>          </div><h2 id="第二章-数据的运算和表示"><a href="#第二章-数据的运算和表示" class="headerlink" title="第二章 数据的运算和表示"></a>第二章 数据的运算和表示</h2><p><img src="/img/C-O/2.1.png"></p><h3 id="2-1-数制与编码"><a href="#2-1-数制与编码" class="headerlink" title="2.1 数制与编码"></a>2.1 数制与编码</h3><h4 id="2-1-1进位计数制及其相互转换"><a href="#2-1-1进位计数制及其相互转换" class="headerlink" title="2.1.1进位计数制及其相互转换"></a>2.1.1进位计数制及其相互转换</h4><p><img src="/img/C-O/2.1.1.png"></p><h4 id="2-1-2-机器数与真值"><a href="#2-1-2-机器数与真值" class="headerlink" title="2.1.2 机器数与真值"></a>2.1.2 机器数与真值</h4><p><strong>机器数：</strong>把符号“数字化”的数称为机器数。<code>将“符号-&gt;数字化”的数，一般为二进制数，比如带符号位的4位二进制数0110，最高位8就是符号位，这个数的真值就是+6</code></p><p><strong>真值</strong>：带“+”或”-“符号的数称为真值。<code>比如：+5、+7。真值是机器数所代表的实际值，一般为十进制数</code></p><h4 id="2-1-3-什么是BCD码？"><a href="#2-1-3-什么是BCD码？" class="headerlink" title="2.1.3 什么是BCD码？"></a>2.1.3 什么是BCD码？</h4><ul><li>简单来说，就是用<code>4位二进制数表示1位十进制数（0~9），是一种二进制的数字编码形式，用二进制编码来替代十进制代码</code></li><li>BCD码可分成两类：<strong>有权码</strong>和<strong>无权码</strong>。</li><li>为什么使用BCD码：这种编码技巧最常用于会计系统的设计里，因为会计制度经常需要对很长的数字串作准确的计算。相对于一般的浮点式记数法，采用BCD码，即可保存数值的精确度，又可免去使计算机作浮点运算时所耗费的时间。此外，对于其他需要高精确度的计算，BCD编码亦很常用。</li></ul><h5 id="有权码和无权码："><a href="#有权码和无权码：" class="headerlink" title="有权码和无权码："></a>有权码和无权码：</h5><p><img src="/img/C-O/2.1.2.png"></p><h5 id="8421码的计算："><a href="#8421码的计算：" class="headerlink" title="8421码的计算："></a>8421码的计算：</h5><ul><li>当两个8421码进行计算时，如果结果小于等于0，则不作任何操作，如果计算结果大于9，则需要进行+6（0110）修正操作，并向高位进位。</li></ul><blockquote><p>计算5+8：</p><p>​8421 BCD替换： 0101+1000 &#x3D; 1101 </p><p>​此时大于9，需要加上6&#x3D;0110 —&gt;10011，此时1为高位，0011为低位，满足BCD：即13</p></blockquote><h4 id="2-1-4-什么是ASCII码？"><a href="#2-1-4-什么是ASCII码？" class="headerlink" title="2.1.4 什么是ASCII码？"></a>2.1.4 什么是ASCII码？</h4><ul><li>我们知道我们日常见到的数字（0-9）、符号比如：#、%、+、@等、英语字母如：(A-z)、(a~z),它们在计算机中都是以二进制来表示存储的，咱们可以用不同的二进制数来表示，但是为了统一化、使大家的相互通信可以正常进行，那么就必须制定一套统一的标准来规范它，由此ASCII码随之诞生，大家都遵从这一统一的标准进行数据的通信和交流。</li></ul><h4 id="2-1-5-校验码（略）"><a href="#2-1-5-校验码（略）" class="headerlink" title="2.1.5 校验码（略）"></a>2.1.5 校验码（略）</h4><h5 id="1-什么是校验码"><a href="#1-什么是校验码" class="headerlink" title="1.什么是校验码"></a>1.什么是校验码</h5><ul><li>校验码：指能够发现或能够自动纠正错误的数据编码，也称检错纠错编码</li><li>实现原理：通过加一冗余码，来检验或纠错编码</li><li>码距：简单来说就是两个二进制数比较，在同一数位的地方数值位不同的个数有多少个，即码距，也称海明距离。</li><li>两种方法计算码距：如0100和0111：<ul><li><code>直接观察法</code>：可以看出有3个数值位不同，码距为3</li><li><code>异或计算法</code>：0100⊕1111&#x3D;1011 ，结果为1011，里面有几个1就代表有多少个数位值不同，即码距是多少，这里码距是3。</li></ul></li></ul><h5 id="2-为什么要有校验码？"><a href="#2-为什么要有校验码？" class="headerlink" title="2.为什么要有校验码？"></a>2.为什么要有校验码？</h5><ul><li>其实从什么是校验码，就可以看出为什么要有校验码，在计算机的运算过程中，所有数据都是以二进制保存的，数据在计算机中进行运算处理传递的时候，我们要对数据进行加工，为什么要加工呢？是为了防止在传输过程中由于硬件等方面的因素导致数据发生变化，当我们加工数据增加冗余位后，原始数据码就变成了校验码，我们可以通过相对应的校验码的一些方法来检测和纠正错误，保证数据的准确性</li></ul><h3 id="2-2-定点数的表示和运算"><a href="#2-2-定点数的表示和运算" class="headerlink" title="2.2 定点数的表示和运算"></a>2.2 定点数的表示和运算</h3><h4 id="2-2-1-定点数的表示"><a href="#2-2-1-定点数的表示" class="headerlink" title="2.2.1 定点数的表示"></a>2.2.1 定点数的表示</h4><h5 id="1-有符号数和无符号数"><a href="#1-有符号数和无符号数" class="headerlink" title="1.有符号数和无符号数"></a>1.有符号数和无符号数</h5><ul><li><p>无符号数：指整个机器字长的全部二进制位均为数值位，没有符号位。若机器字长为8位，则数的表示范围 0<del>2^8^-1 , 即0</del>255。</p></li><li><p>有符号数：在机器中，数的正负我们无法识别，但是我们可以用二进制数来代替正负号。一般‘0’为正，‘1’为负，符号位一般在有效数的最前面。若机器字长为8位，是有符号数，则数的表示范围为 -2^7^<del>2^7^-1 ，即-128</del>127。</p></li></ul><p><font color=red>注：讨论的原码等是建立在有符号数的前提上，也就是说最高位是符号位</font></p><h5 id="2-机器数的定点表示"><a href="#2-机器数的定点表示" class="headerlink" title="2.机器数的定点表示"></a>2.机器数的定点表示</h5><ul><li>根据小数点的位置是否固定，在计算机中，有两种数据格式：定点和浮点表示</li><li>定点表示即约定机器数中小数点位置是固定不变的，小数点不再用“.”表示，而是约定它的位置</li><li>定点小数：一般将小数点的位置固定在数据的<code>最高位之前</code></li><li>定点整数：一般将小数点的位置固定在数据的<code>最高位之后</code></li></ul><h5 id="3-原码、补码、反码、移码"><a href="#3-原码、补码、反码、移码" class="headerlink" title="3.原码、补码、反码、移码"></a>3.原码、补码、反码、移码</h5><p><strong>原码</strong>：符号位“0”表示正数，“1”表示负数，数值位即真值的绝对值</p><p><strong>反码</strong>：通常用来作为原码求补码，或补码求原码的中间过渡、正数反码就是正数</p><p><strong>补码</strong>：可以将减法操作化作加法操作。正数的补码是其本身, 负数的补码可以看作对其原码<strong>除符号位外, 每位求反, 末位加1。特别地, [x]补 经过符号位和数值位按位取反+1 得到[-x]补。</strong></p><p><strong>移码</strong>：针对补码无法直接比较大小而引出的一种表示法，即对补码加上一个$$2^n$$，即将最高位符号位取反</p><p><strong>除0</strong>：故障</p><p><strong>长字节转短字节</strong>：截断高位</p><p><strong>短字节转长字节</strong>：符号扩展</p><blockquote><p>备注: </p><ol><li>十进制小数不一定都能用二进制表示。</li><li>原码, 反码的表示在数轴上对称, 存在+0和-0；而补码, 移码的0是唯一的。</li><li>移码和补码的符号位相反, 数值位相同</li><li>负数的补码中, 数值部分越大, 真值越大(更靠近0), 多表示一个最小负数</li><li>移码保持数据原有大小顺序, 移码大则真值大</li><li>补码符号位可以参与运算</li></ol></blockquote><ul><li>移码越大真值越大，移码越小真值越小</li><li>[+0]原 &#x3D; 0000 , [-0]原 &#x3D; 1000<br>  [+0]补 &#x3D; [-0]补 &#x3D; 0.000<br>  [+0]反 &#x3D; 0.000 , [-0]反 &#x3D; 1.111</li></ul><p><img src="/img/C-O/2.2.1.jpg"></p><h4 id="2-2-2-定点数的运算"><a href="#2-2-2-定点数的运算" class="headerlink" title="2.2.2 定点数的运算"></a>2.2.2 定点数的运算</h4><h5 id="1-定点数移位运算"><a href="#1-定点数移位运算" class="headerlink" title="1.定点数移位运算"></a>1.定点数移位运算</h5><ul><li>移位运算：根据操作对象不同分为算术移位和逻辑移位</li><li>算术移位：有符号数的移位</li><li>逻辑移位：操作对象是逻辑代码，可视为无符号数</li></ul><p>（1）算术移位</p><ul><li>算术移位规则（未溢出，未移出）</li></ul><p><img src="/img/C-O/2.2.2.png"></p><p>（2）逻辑移位</p><ul><li>移位规则：左移右移都是填0</li></ul><h5 id="2-定点数加减法运算"><a href="#2-定点数加减法运算" class="headerlink" title="2.定点数加减法运算"></a>2.定点数加减法运算</h5><p>（1）原码加减</p><ul><li>加法：绝对值相加，符号位不变</li><li>减法：绝对值大的减绝对值小的数，结果的符号和绝对值大的数相同</li><li>这里的加法运算，其实当两个数符号位不同时就按减法规则算</li><li>注意：运算时超出字长，则左边溢出位丢掉</li></ul><p>（2）补码加减</p><p>为什么机器中使用补码运算规则？</p><ul><li>补码统一了符号位和数值位，加法和减法也可以统一处理，只需要加法器，不需要减法器，节省元件，简化了运算器的设计，提高效率</li><li>注意：符号位与数值位一起运算，符号位产生的进位丢掉，结果的符号位数值由运算得出</li></ul><p><img src="/img/C-O/2.2.3.jpg"></p><h5 id="3-符号扩展"><a href="#3-符号扩展" class="headerlink" title="3.符号扩展"></a>3.符号扩展</h5><ul><li>符号扩展：有时需要把两种不同位数的数相加，那么需要统一他们的位数，比如8位和16位数相加，要想得到正确的结果，必须把8位数转换成16位数</li></ul><p>（1）正数符号扩展</p><ul><li>原码&#x3D;补码&#x3D;反码：比如8位转16位：+12(10) &#x3D; 0000 1100 , 转换成16位则为：0000 0000 0000 1100</li><li>符号位为0，附加为都用0补充</li></ul><p>（2）负数符号扩展</p><p>比如8位转16位：-12 (10) &#x3D; 1000 1100</p><ul><li>原码：扩展方法与正数符号扩展相同，只不过最高位符号位变为1, 1000 0000 0000 1100</li><li>补码：附加位补充1，符号位为1，1111 1111 1111 1100</li><li>反码：附加位补充1，符号位为1，1111 1111 1111 1100</li></ul><h5 id="4-溢出概念和判别方法"><a href="#4-溢出概念和判别方法" class="headerlink" title="4.溢出概念和判别方法"></a>4.溢出概念和判别方法</h5><ul><li>溢出：指参加运算的两个数，相加或相减，运算结果超过了机器字长所能表示的范围</li><li>正溢出：运算结果大于机器字长所能表示的最大正数</li><li>负溢出：运算结果小于机器字长所能表示的最小负数</li></ul><h5 id="5-定点数乘法运算"><a href="#5-定点数乘法运算" class="headerlink" title="5.定点数乘法运算"></a>5.定点数乘法运算</h5><p>（1）原码一位乘法</p><ul><li>运算细则：</li></ul><ol><li>被乘数和乘数均取绝对值参加运算，符号位异或运算；</li><li>部分积的长度和被乘数一样，取n+1位，初值为0；</li><li>从乘数的最低位yn开始判断；若yn&#x3D;1，则高位部分积加上被乘数|x| , 高位部分积然后右移一位；若yn&#x3D;0，则高位部分积加上0，高位部分积右移一位；</li><li>重复2步骤，判断n次</li></ol><p><font color =red>符号位异或操作，同为0假，异为1真。其余进行绝对值求积</font></p><p>（2）补码一位乘法（Booth算法）<strong>（略）</strong></p><ul><li>一种有符号的乘法，采取相加和相减操作计算补码数据的乘积。</li><li>运算规则：</li></ul><ol><li>符号位参与运算，运算的数均以补码表示</li><li>被乘数一般取双符号位参与运算，部分积取双符号位，初值为0，乘数可取单符号位</li><li>乘数末位增设附加位yn+1，初值为0</li><li>根据（yn,yn+1）的取值来确定操作，见下表规则</li><li>有符号数，移位按补码右移算术移位规则进行，右移补充1，左移补充0</li><li>按上诉步骤进行n+1次步骤，第n+1次不移位。累加n+1次，移位n次</li></ol><h5 id="6-定点数除法运算"><a href="#6-定点数除法运算" class="headerlink" title="6.定点数除法运算"></a>6.定点数除法运算</h5><ul><li>在计算机中，除法运算可转换成<code>累加+左移（逻辑左移）</code></li></ul><p>（1）原码除法运算（不恢复余数法）</p><ul><li>采用方法：原码不恢复余数法，也称原码加减交替除法，符号位和数值单独处理</li></ul><p><img src="/img/C-O/2.2.4.jpg"></p><h3 id="2-3-浮点数的表示和运算"><a href="#2-3-浮点数的表示和运算" class="headerlink" title="2.3 浮点数的表示和运算"></a>2.3 浮点数的表示和运算</h3><p><img src="/img/C-O/2.2.3.png"></p><h4 id="1-基本格式"><a href="#1-基本格式" class="headerlink" title="1.基本格式"></a>1.基本格式</h4><p><img src="/img/C-O/2.3.1.png"></p><p>例子：</p><p><img src="/img/C-O/2.3.2.png"></p><h4 id="2-规格化"><a href="#2-规格化" class="headerlink" title="2.规格化"></a>2.规格化</h4><p><img src="/img/C-O/2.3.3.png"></p><h4 id="3-IEEE-754标准"><a href="#3-IEEE-754标准" class="headerlink" title="3.IEEE 754标准"></a>3.IEEE 754标准</h4><p><img src="/img/C-O/2.3.4.png"></p><h4 id="4-浮点数加减运算："><a href="#4-浮点数加减运算：" class="headerlink" title="4.浮点数加减运算："></a>4.浮点数加减运算：</h4><p>浮点数加减运算步骤：</p><ol><li>对阶</li><li>尾数加减</li><li>规格化</li><li>舍入</li><li>判溢出</li></ol><p>例子：</p><p><img src="/img/C-O/2.3.5.png"></p><h3 id="2-4-算术逻辑单元ALU与加法器-略"><a href="#2-4-算术逻辑单元ALU与加法器-略" class="headerlink" title="2.4 算术逻辑单元ALU与加法器(略)"></a>2.4 算术逻辑单元ALU与加法器(略)</h3><p><img src="/img/C-O/2.3.6.png"></p><h2 id="第三章-存储系统"><a href="#第三章-存储系统" class="headerlink" title="第三章 存储系统"></a>第三章 存储系统</h2><h2 id="第四章-指令系统"><a href="#第四章-指令系统" class="headerlink" title="第四章 指令系统"></a>第四章 指令系统</h2><h2 id="第五章-中央处理器"><a href="#第五章-中央处理器" class="headerlink" title="第五章 中央处理器"></a>第五章 中央处理器</h2><h2 id="第六章-总线"><a href="#第六章-总线" class="headerlink" title="第六章 总线"></a>第六章 总线</h2><h3 id="2-1-总线概念及性能指标"><a href="#2-1-总线概念及性能指标" class="headerlink" title="2.1 总线概念及性能指标"></a>2.1 总线概念及性能指标</h3><p><strong>传送周期（总线周期）</strong>：一次总线操作所需时间，包含申请阶段，寻址阶段，传输阶段等</p><p><strong>总线的时钟周期</strong>：即机器时钟周期</p><p><strong>总线的工作频率</strong>：总线周期的倒数</p><p><strong>总线的时钟频率</strong>：时钟周期的倒数</p><p><strong>总线宽度</strong>：数据总线的根数</p><p><strong>总线带宽</strong>：总线宽度 * 总线工作频率</p><p><strong>主设备</strong>：发出总线请求且获得总线控制权的设备</p><p><strong>从设备</strong>：指被主设备访问的设备</p><p><strong>片内总线</strong>：CPU内部各寄存器之间及ALU的连接</p><p><strong>系统总线：</strong></p><ul><li>数据总线：双向传输总线，位数与机器字长、存储字长有关</li><li>地址总线：指明CPU访问的存储单元或I&#x2F;O端口的地址，单项传输，位数与存储单元有关</li><li>控制总线：用来发出各种控制信号的传输线，单向传输</li><li>猝发传送：传输一次首地址和一组数据</li><li>I&#x2F;O总线与通信总线：CPU和主存通过I&#x2F;O总线与主机相连，I&#x2F;O接口通过通信总线（电缆）与外设相连</li></ul><h5 id="1-总线的定义"><a href="#1-总线的定义" class="headerlink" title="1.总线的定义"></a>1.总线的定义</h5><p>总线是一组能为多个部件<strong>分时共享</strong>的公共信息传送线路。</p><h5 id="2-为什么要用总线？"><a href="#2-为什么要用总线？" class="headerlink" title="2.为什么要用总线？"></a>2.为什么要用总线？</h5><p>早期计算机外部设备少时大家采用分散连接方式，不易实现随时增减外部设备，为了更好地解决I&#x2F;O设备和主机之间连接的灵活性问题，计算机的结构从分散链接发展为总线连接。</p><h5 id="3-总线的特性"><a href="#3-总线的特性" class="headerlink" title="3.总线的特性"></a>3.总线的特性</h5><blockquote><p>机械特性：尺寸、形状、管脚数、排列顺序</p><p>电气特性：传输方向和有效的电平范围</p><p>功能特性：每根传输线的功能（地址，数据，控制）</p><p>时间特性：信号的时序关系</p></blockquote><h2 id="第七章-输入-输出系统"><a href="#第七章-输入-输出系统" class="headerlink" title="第七章 输入&#x2F;输出系统"></a>第七章 输入&#x2F;输出系统</h2>]]></content>
    
    
    
    <tags>
      
      <tag>408</tag>
      
      <tag>Computer Organization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/Linux/"/>
    <url>/Linux/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AndroidApp</title>
    <link href="/AndroidApp/"/>
    <url>/AndroidApp/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-应用开发模式"><a href="#Android-应用开发模式" class="headerlink" title="Android 应用开发模式"></a>Android 应用开发模式</h1><div class="note note-primary">            <p>本内容结合博主自己开发Android App的经历，在这中间遇到很多的波折，将这些整理下来并且给予初学者一个帮助，本文将通过最简单的方式带你入门，并且独自开发一个app。</p>          </div><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>参考资料：《Android Sudio开发实践——从零基础到App上线》欧阳燊<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>参考内容：……<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>软件开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>System Operation</title>
    <link href="/System/"/>
    <url>/System/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-操作系统概述"><a href="#第一章-操作系统概述" class="headerlink" title="第一章 操作系统概述"></a>第一章 操作系统概述</h1><div class="note note-primary">            <p>本文主要针对408考研内容编写，以及Linux等操作。</p>          </div><h2 id="1-1-操作系统简介"><a href="#1-1-操作系统简介" class="headerlink" title="1.1 操作系统简介"></a>1.1 操作系统简介</h2><p><code>操作系统能做什么？</code></p><div class="note note-warning">            <ul><li>从用户的角度：<ol><li>提供良好的用户界面</li><li>标准的函数库</li><li>使得编程更加方便并且不容易出错</li></ol></li><li>从系统的角度：<ol><li>管理资源（硬件资源、处理机、存储器、设备；信息资源【文件】）</li><li>解决申请资源时产生的冲突</li><li>阻止错误的产生和计算机不正当的使用</li></ol></li></ul>          </div><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p><font color="red">操作系统（Operation System，OS）</font>：是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本你爹系统软件。</p><blockquote><ul><li><p>An operating system acts an intermediary between user of a computer and the computer</p><p>  hardware.</p><ul><li>操作系统充当计算机⽤⼾和计算机硬件之间的中介</li></ul></li><li><p>The purpose of an operating system is to provide an environment in which a user can execute</p><p>  programs in a convenient and efficient manner.</p><ul><li>操作系统的⽬的是提供⼀个⽤⼾可以⽅便和有效地执⾏程序的环境</li></ul></li><li><p>An operating system is software that manages the computer hardware.</p><ul><li>操作系统是管理计算机硬件的软件</li></ul></li></ul></blockquote><p><img src="/img/System/1.1.png" alt="现代计算机硬件结构"></p><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><div class="note note-success">            <p>这里的内容以及和下面的<strong>存储器</strong>，<strong>I&#x2F;O设备</strong>，<strong>总线</strong>等都是计算机组成原理中的重要内容，在本文中也是按照书中给的内容进行叙述。下面有链接可以查看具体的讲解。（部分内容已经脱离408考点，主要是知识扩展）</p>          </div><blockquote><p>处理器（中央处理器（Central Processing Unit）—— CPU）：</p><ul><li><p>CPU工作的基本周期是：提取指令，译码分析，执行指令。（接化发！<code>链接中有讲到</code>）</p></li><li><p>CPU内部包含若干寄存器</p><ul><li><p>通用寄存器：</p><p>  ​用来存放关键变量和中间结果。</p></li><li><p>专用寄存器：</p><ul><li><p>程序计数器（PC）：</p><p>  ​PC中保存下面要提取指令的内存地址。</p></li><li><p>栈指针寄存器：</p><p>  ​存放指向当前内存栈的顶端的指针；该栈中保存有关函数（过程）调用时的现场信息，包括输入参数、局部变量和未在寄存器中保存的临时变量。</p><p>  ​程序执行过程中调用的每个函数在栈中站有一个帧面。</p></li><li><p>程序状态字（PSW）：</p><p>  ​条件码位、CPU优先级、程序执行模式（<strong>用户态</strong>或者<strong>核心态</strong>）和各种其他控制位。</p><p>  ​在系统调用和I&#x2F;O中PSW起重要作用。</p></li></ul></li></ul></li><li><p>处理机执行状态——保护操作系统程序，防止收到用户程序的损害：</p><ul><li><p>用户态</p><p>  ​用户程序（各种应用程序、工具、例程等）在用户态下执行，它们权限较低，只能执行指令集中非特权指令。</p></li><li><p>核心态（系统态、管理态）</p><p>  ​处于核心态，有较高特权，可以执行所有指令，包括普通用户程序中不能使用的<strong>特权指令</strong>，从而能对<strong>所有寄存器</strong>和<strong>内存</strong>进行访问，以及<strong>启动I&#x2F;O操作</strong>等。</p></li></ul></li></ul><p></p></blockquote><p><a href="https://polaris516.github.io/CO_CPU">中央处理器——CPU</a></p><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><blockquote><p>存储器（memory）：按照速度、容量和成本划分，存储器系统构成一个层次结构。（如图1.2）</p><ul><li><p>顶层是CPU的内部寄存器，速度和CPU一样快，存取它们没有延迟。但成本高，容量小，通常小于1KB</p></li><li><p>高速缓存：</p><p>  ​当程序需要读取具体信息时，Cache硬件先查看它是否在Cache中，如果在其中（“命中”），就直接使用它；反之，就从内存中获取该信息，并把它放入Cache中。小于4MB</p></li><li><p>内存（主存）：</p><ul><li>存储器系统的主力，也称作RAM（随机存取存储器）</li><li>CPU可以直接存取内存及寄存器和Cache中的信息。</li><li>机器执行的指令及所用的数据必须先存放在内存及Cache和寄存器中。</li><li>内存中存放的信息是易失的，当机器电源被关闭后，内存中的信息就全部丢失了。</li></ul></li><li><p>磁盘（硬盘、辅助存储器或者辅存、外存）：</p><ul><li>对内存的扩展</li><li>磁盘上可以永久保留数据，容量特别大</li><li>磁盘上数据的存取速度低于内存存取速度</li></ul></li><li><p>磁带</p><ul><li>数据永久保存，容量很大，存取速度很慢，不适宜随机存取。</li><li>主要作为文件系统的后备，存放不常用的信息或用做系统间的传送信息的介质。</li></ul></li><li><p>其他存储器：如软盘，光盘（CD-ROM）、U盘等</p></li></ul></blockquote><p><img src="/img/System/1.2.1.png" alt="图1.2"></p><p><a href="https://polaris516.github.io/CO_Memory">存储器——Memory</a></p><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h3><blockquote><ul><li><p>控制器：</p><p>  ​控制器是I&#x2F;O设备的电子部分，它协调和控制一台或多台I&#x2F;O设备的操作，实现设备操作与整个系统操作的同步。</p></li><li><p>设备:</p><p>  ​本身的对外接口相当简单，实际上他们隐藏在控制器后面</p></li></ul><p>设备驱动程序：向控制器发布命令并接收其回答信息的软件。</p></blockquote><ul><li>存储器只是众多IO设备的一种，IO设备是计算机体系结构中种类最丰富的设备类型，而且它有着很强的扩展性</li><li>管理IO设备是操作系统非常重要的组成成分，操作系统中有一个专门的IO子系统负责完成这项工作。</li></ul><p><a href="https://polaris516.github.io/CO_I-O">I&#x2F;O设备</a></p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><blockquote><ul><li><p>数据总线：</p><p>  ​计算机各部件之间传送数据的通道，其宽度随字长而定</p><p>  ​数据总线是双向总线，即两个方向都能传送数据</p></li><li><p>地址总线：</p><p>  ​从CPU送来地址的地址线，它可以是存储器的地址，也可以是IO设备控制器中中控制寄存器或数据寄存器的地址</p></li><li><p>控制总线：</p><p>  ​在该线上出现的信号是各个模块之间传送数据时所需的全部控制信号</p></li></ul></blockquote><h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><p><img src="/img/System/1.2.2.png"></p><h4 id="1-并发："><a href="#1-并发：" class="headerlink" title="1.并发："></a>1.并发：</h4><p><code>并发</code>：两个或多个事件在同一个时间间隔内发生，这些事件在宏观上是同时发生的，在微观上是交替发生的，操作系统的并发性指系统中同时存在着多个运行的程序</p><p><code>并行</code>：两个或多个事件在同一个时刻发生</p><p>一个单核（CPU）同一时刻只能执行一个程序，因此操作系统会协调多个程序使他们交替进行（这些程序在宏观上是同时发生的，在微观上是交替进行的）</p><p>操作系统是伴随着“多道程序技术出现的”，因此操作系统和并发是一同诞生的</p><p>在如今的计算机中，一般都是多核CPU的，即在同一时刻可以并行执行多个程序。</p><h4 id="2-共享："><a href="#2-共享：" class="headerlink" title="2.共享："></a>2.共享：</h4><ul><li>资源共享即共享，是指系统中的资源可以<code>供内存中多个并发执行的进程</code>共同使用</li><li>共享分为两类：互斥共享和同时共享<ol><li>互斥共享<ul><li>计算机中的某个资源在一段时间内只能允许一个进程访问，别的进程没有使用权</li><li>临界资源（独占资源）：在一段时间内只允许一个进程访问，别的进程没有使用权</li><li>eg：QQ和微信视频，同一段时间内摄像头只能分配给其中一个进程</li></ul></li><li>同时共享<ul><li>计算机中的某个资源在一段时间内可以同时允许多个进程访问</li><li>同时共享通常要求一个请求分为几个时间片段间隔的完成，即交替进行，“分时共享”</li><li>这里的同时指在宏观上是同时的，在微观上是交替进行访问的，只是CPU处理速度很快，我们感觉不到。在宏观上感觉是在同时进行</li><li>eg：比如QQ在发送文件A，微信在发送文件B，宏观上两个进程A和B都在访问磁盘，在我们看来是同时进行的，但是在微观上两个进程A和B是交替进行的，只是时间太短，cpu处理速度太快，我们感觉不到。</li><li><code>注意</code>：有时候多个进程可能真的是在同时进行资源访问，比如玩游戏时可以放音乐，游戏声音和音乐声音都能听见</li></ul></li></ol></li></ul><h4 id="3-并发和共享的关系"><a href="#3-并发和共享的关系" class="headerlink" title="3.并发和共享的关系"></a>3.并发和共享的关系</h4><p>并发性指计算机系统中同时存在着多个运行着的程序</p><p>共享性是指系统中的资源可供内存中多个并发执行的进程共同使用</p><ul><li>从上述例子来看二者之间的关系：<ol><li>两个进程正在并发执行（并发性）</li><li>需要共享地访问硬盘资源（共享性）</li></ol></li></ul><p><code>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义</code></p><p><code>如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发</code></p><h4 id="4-虚拟"><a href="#4-虚拟" class="headerlink" title="4.虚拟"></a>4.虚拟</h4><blockquote><p>多道程序设计：是指在计算机内存中同时存放几道互相独立的程序，使它们在管理程序控制之下，相互穿插的运行。两个或两个以上的程序在计算机系统中同处于开始到结束之间的状态。这就称为多道程序设计。多道程序技术运行的特征：多道、宏观上并行、微观上串行。</p></blockquote><ul><li>虚拟是把一个物理上的实体变为若干逻辑上的对应物</li><li>物理实体（前者）是实际存在的；而后者是虚的，是用户感觉上的事务</li><li>虚拟技术：用于实现虚拟的技术</li><li>虚拟处理器（CPU）：通过多道程序设计技术，采用让多道程序并发执行的方法，分时来使用一个CPU，实际物理上只有一个CPU，但是用户感觉到有多个CPU</li><li>虚拟存储器：从逻辑上扩充存储器容量，用户感觉到的但实际不存在的存储器</li><li>虚拟设备：将一台物理设备虚拟为逻辑上的多台设备，使多个用户在同一时间段内访问同一台设备，即同时共享，用户宏观上感觉是同时的，但实际上是微观交替访问同一台设备</li><li>操作系统的虚拟技术可归纳为：<ul><li>时分复用技术：如处理器的分时共享</li><li>空间复用技术：如虚拟处理器</li></ul></li></ul><p><code>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此没有并发性，就谈不上虚拟性</code></p><h4 id="5-异步"><a href="#5-异步" class="headerlink" title="5.异步"></a>5.异步</h4><ul><li>异步：多道程序环境允许多个程序并发执行，但由于资源有限，如cpu只有一个，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进。</li><li>比如A进程正在占用CPU计算，B进程这时也想占用CPU计算，B进程只有等，等A进程算完了，A进程去访问磁盘资源了，这时B进程再占用CPU进行计算，B进程还没计算完，A进程从磁盘取出资源了，A进程发现B这时在占用CPU，这时A进程就需要等待，等B算完后再继续到CPU中进行计算。由于每个进程占用资源的时间不固定，所以进程的执行以不可预知的速度前进</li></ul><h2 id="1-2-处理器系统"><a href="#1-2-处理器系统" class="headerlink" title="1.2 处理器系统"></a>1.2 处理器系统</h2><p><img src="/img/System/1.3.1.png"></p><h3 id="单处理器系统"><a href="#单处理器系统" class="headerlink" title="单处理器系统"></a>单处理器系统</h3><ul><li>Single-progress System</li><li>只有一颗注CPU，执行通用指令集</li><li>带有其他专用处理器，为特定设备服务，如：磁盘、键盘、图形控制器等<ul><li>它们能够执行的指令有限，不处理用户进程</li><li>操作系统会向它们发出任务，并监控它们的状态</li></ul></li></ul><h3 id="多处理器系统"><a href="#多处理器系统" class="headerlink" title="多处理器系统"></a>多处理器系统</h3><ul><li>Multi processor&#x2F;Muliticore System</li><li>有两个或多个紧密通信的CPU，它们共享计算机总线、时钟、内存和外设等。</li></ul><h3 id="集群系统"><a href="#集群系统" class="headerlink" title="集群系统"></a>集群系统</h3><ul><li>Clustered System</li><li>该系统由若干节点（Node）通过网络连接在一起，每个节点可为单处理器系统或多处理器系统，节点之间是松耦合（loosely coupled)关系<ul><li>高可用性（high availability）</li><li>高性能计算（high-performance computing)</li></ul></li></ul><h3 id="单道单用户模式"><a href="#单道单用户模式" class="headerlink" title="单道单用户模式"></a>单道单用户模式</h3><p><img src="/img/System/1.3.png" alt="单道单用户模式"></p><h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><ul><li>操作系统最重要的一点是具有多道程序的能力</li><li>单道程序不能让CPU和IO设备始终忙碌，多道程序设计通过安排任务使用的CPU总有一个执行任务，从而提高CPU利用率</li><li>实现的硬件保证：处理器和IO设备具有并行工作的能力</li></ul><h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><ul><li>分时系统也称多任务系统，是多道程序设计的自然延伸</li><li>允许多个用户共享一台计算机<ul><li>用户只有输入和输出设备</li><li>分时系统为每个用户轮流分配等量的CPU时间</li><li>用户从发出指令得到得到即时结果的时间称为响应时间</li></ul></li><li>第一个分时系统CTSS由MIT于1962年开发出来</li></ul><h2 id="1-3-操作系统的发展历程："><a href="#1-3-操作系统的发展历程：" class="headerlink" title="1.3 操作系统的发展历程："></a>1.3 操作系统的发展历程：</h2><p><img src="/img/System/1.3.2.png"></p><h2 id="1-4-操作系统的运行机制和体系结构"><a href="#1-4-操作系统的运行机制和体系结构" class="headerlink" title="1.4 操作系统的运行机制和体系结构"></a>1.4 操作系统的运行机制和体系结构</h2><h3 id="1-4-1-操作系统的运行机制和体系结构"><a href="#1-4-1-操作系统的运行机制和体系结构" class="headerlink" title="1.4.1 操作系统的运行机制和体系结构"></a>1.4.1 操作系统的运行机制和体系结构</h3><h4 id="1-操作系统的运行机制和体系结构"><a href="#1-操作系统的运行机制和体系结构" class="headerlink" title="1.操作系统的运行机制和体系结构"></a>1.操作系统的运行机制和体系结构</h4><p><img src="/img/System/1.5.1.png"></p><h4 id="2-操作系统体系结构类比"><a href="#2-操作系统体系结构类比" class="headerlink" title="2.操作系统体系结构类比"></a>2.操作系统体系结构类比</h4><p>类比：</p><p>操作系统体系结构问题与企业的管理问题很相似。</p><p>内核就是企业的管理层，负责一些重要的工作。只有管理层才能执行特权指令，普通员工只能执行非特权指令。用户态，核心态之间的切换相当于普通员工和管理层之间的工作交接</p><p>大内核：企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高；缺点是组织结构混乱，难以维护</p><p>微内核：随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护；缺点是效率低</p><h4 id="3-操作系统用户态和核心态的转换"><a href="#3-操作系统用户态和核心态的转换" class="headerlink" title="3.操作系统用户态和核心态的转换"></a>3.操作系统用户态和核心态的转换</h4><p>“用户态 -&gt; 核心态”是通过中断实现的。并且中断是唯一途径。“核心态 -&gt; 用户态”的切换是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”</p><h3 id="1-4-2-中断和异常"><a href="#1-4-2-中断和异常" class="headerlink" title="1.4.2 中断和异常"></a>1.4.2 中断和异常</h3><p><img src="/img/System/1.5.2.png"></p><p> 中断</p><ul><li>当有事件（event）发生时，CPU会收到一个中断（interrupt）信号，可以是硬中断也可以是软中断</li><li>CPU会停下正在做的事，转而执行中断处理程序，执行完毕会回到之前被中断的地方继续执行</li><li>Operation System is an Interrupt driven system<ul><li>操作系统是一个由中断驱动的系统</li></ul></li></ul><h3 id="1-4-3-系统调用（执行过程、访管指令、库函数与系统调用）"><a href="#1-4-3-系统调用（执行过程、访管指令、库函数与系统调用）" class="headerlink" title="1.4.3 系统调用（执行过程、访管指令、库函数与系统调用）"></a>1.4.3 系统调用（执行过程、访管指令、库函数与系统调用）</h3><p><img src="/img/System/1.4.3.png"></p><h1 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h1><h2 id="2-1-进程与线程"><a href="#2-1-进程与线程" class="headerlink" title="2.1 进程与线程"></a>2.1 进程与线程</h2><h3 id="2-1-1-进程的定义、特征、组成、组织"><a href="#2-1-1-进程的定义、特征、组成、组织" class="headerlink" title="2.1.1 进程的定义、特征、组成、组织"></a>2.1.1 进程的定义、特征、组成、组织</h3><h4 id="1-进程的定义"><a href="#1-进程的定义" class="headerlink" title="1.进程的定义"></a>1.进程的定义</h4><h5 id="1-程序的概念"><a href="#1-程序的概念" class="headerlink" title="1.程序的概念"></a>1.程序的概念</h5><p>程序：就是一个指令序列</p><h5 id="2-进程的概念（引入多道程序技术之后）"><a href="#2-进程的概念（引入多道程序技术之后）" class="headerlink" title="2.进程的概念（引入多道程序技术之后）"></a>2.进程的概念（引入多道程序技术之后）</h5><ul><li>为了方便操作系统管理，完成各程序并发执行，引入了进程，进程实体的概念</li><li>PCB、程序段、数据段三部分构成了进程实体（进程映像）</li></ul><blockquote><p><font color =orange>进程和程序的区别与联系：</font></p><ol><li><p>进程是动态的，程序是静态的</p></li><li><p>进程有独立性，能并发执行，程序不能并发执行</p></li><li><p>二者无一一对应关系</p></li><li><p>进程异步运行，会相互制约；程序不具备此特征</p><p> 但是，进程和程序又有密切的联系：进程不能脱离具体程序而虚设，程序规定了相应进程所要完成的动作。</p></li><li><p>组成不同：进程包含PCB、程序段、数据段。程序包含数据和指令代码。</p></li><li><p>程序是一个包含了所有指令和数据的静态实体。本身除占用磁盘的存储空间外，并不占用系统如CPU、内存等运行资源。</p></li><li><p>进程由程序段、数据段和PCB构成，会占用系统CPU、内存等运行资源。</p></li><li><p>一个程序可以启动多个进程来共同完成</p></li></ol><p><font color=red>联系：进程不能脱离具体程序而虚设，程序规定了相应进程所要完成的动作。</font></p></blockquote><h5 id="3-进程的定义"><a href="#3-进程的定义" class="headerlink" title="3.进程的定义"></a>3.进程的定义</h5><p>程序段、数据段、PCB三部分组成了进程实体（进程映像）。一般情况下，我们把进程实体就简称为<strong>进程</strong>，例如，所谓创建进程，实质上是创建进程实体中的PCB，而撤销进程，实质上是撤销进程实体中的PCB。</p><p><font color=blue>PCB是进程存在的唯一标志</font></p><p>从不同角度，进程可以有不同的定义，比较传统典型的定义有：</p><ol><li>进程是程序的一次执行过程</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li><li>进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li></ol><p>引入进程实体的概念后，可以把进程定义为：</p><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p><p><font color=red>严格来说，进程和进程实体并不一样，进程实体是静态的，进程则是动态的。不过，除非题目专门考察二者的区别，否则可以认为进程实体就是进程，因此我们也可以说进程实体是由程序段、数据段、PCB三部分组成的。</font></p><h4 id="2-进程的特征"><a href="#2-进程的特征" class="headerlink" title="2.进程的特征"></a>2.进程的特征</h4><p><img src="/img/System/2.1.png"></p><h4 id="3-进程的组成"><a href="#3-进程的组成" class="headerlink" title="3.进程的组成"></a>3.进程的组成</h4><p><strong>PCB（Process Control Block）进程控制块：</strong></p><ul><li><p>PCB中记录了操作系统所需的，用于描述进程的当前情况以及控制进程运行的全部信息。</p><p>  ​PCB的作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位，一个能与其他进程并发运行的进程。</p><p>  ​或者说：<font color=purple>OS是根据PCB对并发执行的进程进行控制和管理的</font></p><p>  ​例如，当OS要<code>调度</code>某进程执行时，要从该进程的PCB中查处其现行状态及优先级；在调度某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据；</p><p>  ​进程在执行过程中，当需要和与之合作的进程实现同步，通信或者访问文件时，也都需要访问PCB；</p><p>  当进程由于某种原因而暂停执行时，又须将器断点的处理机环境保存在PCB中</p><p>  ​可见，在进程的整个生命期中，系统总是通过PCB对进程进行控制的，即系统是根据进程的PCB而不是任何别的什么而感知到该进程的存在的。</p><p>  ​所以说，PCB是进程存在的唯一标志。</p></li></ul><p><img src="/img/System/2.2.png"></p><h4 id="4-进程的组织"><a href="#4-进程的组织" class="headerlink" title="4.进程的组织"></a>4.进程的组织</h4><p>在一个系统中，通常有数十，数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。</p><p><font color = green>进程的组成讨论是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题</font></p><p><img src="/img/System/2.3.png"></p><h3 id="2-1-2-进程的状态及转换"><a href="#2-1-2-进程的状态及转换" class="headerlink" title="2.1.2 进程的状态及转换"></a>2.1.2 进程的状态及转换</h3><p><img src="/img/System/2.4.png"></p><h4 id="1-进程的状态"><a href="#1-进程的状态" class="headerlink" title="1.进程的状态"></a>1.进程的状态</h4><ol><li><p>三种基本状态（就绪、运行、阻塞）</p><p> 进程是程序的一次执行，在这个执行过程中，有时进程被CPU处理，有时又需要等待CPU服务，可见，进程的状态是会有各种变化，为了方便对各个进程的管理，操作系统需要将进程合理地划分为几个状态</p><p> <img src="/img/System/2.5.png"></p></li><li><p>创建态和结束态</p><p> <img src="/img/System/2.6.png"></p></li></ol><h4 id="2-进程状态之间的切换"><a href="#2-进程状态之间的切换" class="headerlink" title="2.进程状态之间的切换"></a>2.进程状态之间的切换</h4><p>进程一共5种状态：运行态，就绪态，阻塞态，创建态，终止态，他们之间如何实现切换？</p><p><img src="/img/System/2.7.png"></p><h3 id="2-1-3-原语实现对进程的控制"><a href="#2-1-3-原语实现对进程的控制" class="headerlink" title="2.1.3 原语实现对进程的控制"></a>2.1.3 原语实现对进程的控制</h3><p><img src="/img/System/2.8.png"></p><h4 id="1-什么是进程控制？"><a href="#1-什么是进程控制？" class="headerlink" title="1.什么是进程控制？"></a>1.什么是进程控制？</h4><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能（<strong>进程控制就是要实现进程状态转换</strong>）</p><h4 id="2-原语实现对进程的控制"><a href="#2-原语实现对进程的控制" class="headerlink" title="2.原语实现对进程的控制"></a>2.原语实现对进程的控制</h4><p><img src="/img/System/2.8.1.png"></p><p>用原语实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成</p><p>这种不能被中断的操作即原子操作。</p><p>原语采用“关中断指令”和“开中断指令”实现</p><h4 id="3-回忆进程组织"><a href="#3-回忆进程组织" class="headerlink" title="3.回忆进程组织"></a>3.回忆进程组织</h4><ul><li>进程在操作系统中的组织使各个进程能够有序的进行切换和运行</li></ul><h4 id="4-进程控制"><a href="#4-进程控制" class="headerlink" title="4.进程控制"></a>4.进程控制</h4><p><code>调度</code>：指决定资源分配给哪个进程的行为，是一种决策行为</p><p><code>切换</code>：指实际分配的行为，是执行行为</p><p>一般来说先有资源调度，后有进程切换</p><h4 id="5-进程控制原语的相同点"><a href="#5-进程控制原语的相同点" class="headerlink" title="5.进程控制原语的相同点"></a>5.进程控制原语的相同点</h4><p>进程控制会导致进程状态的转换。无论是哪个原语，要做的无非三件事情：</p><ol><li>更新PCB中的信息（如修改进程状态标志，将运行环境保存到PCB、从PCB恢复运行环境）<ul><li>所有的进程控制原语一定都会修改进程状态标志</li><li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li><li>某进程开始运行前必然要恢复其运行环境</li></ul></li><li>将PCB插入合适的队列</li><li>分配&#x2F;回收资源</li></ol><h4 id="6-进程控制的5种原语"><a href="#6-进程控制的5种原语" class="headerlink" title="6.进程控制的5种原语"></a>6.进程控制的5种原语</h4><p><code>进程的创建、终止、唤醒、阻塞、切换</code></p><p>（1）进程的创建原语</p><p><img src="/img/System/2.9.png"></p><p>（2）进程的终止原语</p><p><img src="/img/System/2.10.png"></p><p>（3）进程的唤醒和阻塞原语</p><ul><li>进程的阻塞和唤醒原语是成对存在的，必须成对使用</li><li>阻塞原语是由被阻塞进程自我调用实现的</li><li>唤醒原语是由一个被唤醒进程合作或被其他相关进程调用实现的</li></ul><p><img src="/img/System/2.11.png"></p><p>（4）进程的切换原语</p><p><img src="/img/System/2.12.png"></p><h3 id="2-1-4-进程之间的通信"><a href="#2-1-4-进程之间的通信" class="headerlink" title="2.1.4 进程之间的通信"></a>2.1.4 进程之间的通信</h3><p><img src="/img/System/2.13.png"></p><h4 id="1-什么是进程通信？"><a href="#1-什么是进程通信？" class="headerlink" title="1.什么是进程通信？"></a>1.什么是进程通信？</h4><p>顾名思义，进程通信就是指进程之间的信息交换。</p><p>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。</p><p><code>为了保证安全，一个进程不能直接访问另一个进程的地址空间</code>但是进程之间的信息交换又是必须实现的，为了保证进程间的安全通信，操作系统提供了一些方法：共享存储、消息传递、管道通信。</p><h4 id="2-共享存储"><a href="#2-共享存储" class="headerlink" title="2.共享存储"></a>2.共享存储</h4><ul><li>共享一块大家都可以访问的空间，一次只能有一个进程进行读或写操作</li></ul><p><img src="/img/System/2.14.png"></p><h4 id="3-管道通信"><a href="#3-管道通信" class="headerlink" title="3.管道通信"></a>3.管道通信</h4><p>“管道”是指用于连续读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。</p><p><img src="/img/System/2.15.png"></p><ol><li>管道只能采用半双工通信，某一时间段内只能实现单向的传输，如果要实现双向同时通信，则需要设置两个管道。</li><li>各进程要互斥的访问管道</li><li>数据以字符的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。</li><li>如果没写满，就不允许读。如果没读空，就不允许写。</li><li>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。</li></ol><h4 id="4-消息传递"><a href="#4-消息传递" class="headerlink" title="4.消息传递"></a>4.消息传递</h4><ul><li>发送消息的进程将消息头写好，接受消息进程根据消息头读取信息或寻找信封是哪一个</li></ul><p><img src="/img/System/2.16.png"></p><h3 id="2-1-5-线程概念与多线程模型"><a href="#2-1-5-线程概念与多线程模型" class="headerlink" title="2.1.5 线程概念与多线程模型"></a>2.1.5 线程概念与多线程模型</h3><p><img src="/img/System/2.17.png"></p><h4 id="1-为什么要引入线程？"><a href="#1-为什么要引入线程？" class="headerlink" title="1.为什么要引入线程？"></a>1.为什么要引入线程？</h4><p>有的进程可能需要“同时”做很多事，而传统的进程只能串行的执行一系列程序，为此，引入线程，来增加并发度。</p><h4 id="2-什么是线程？"><a href="#2-什么是线程？" class="headerlink" title="2.什么是线程？"></a>2.什么是线程？</h4><ul><li>可以把线程理解成“轻量级进程”</li><li>线程是一个基本的CPU执行单元，也是程序执行流的最小单位，引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提高了系统的并发率，使得一个进程内也可以并发处理各种任务（如QQ视频，文字聊天，传文件）</li><li>引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）</li></ul><h4 id="3-引入进程带来的变化及进程与线程的比较"><a href="#3-引入进程带来的变化及进程与线程的比较" class="headerlink" title="3.引入进程带来的变化及进程与线程的比较"></a>3.引入进程带来的变化及进程与线程的比较</h4><p><img src="/img/System/2.18.png"></p><h4 id="4-线程的属性"><a href="#4-线程的属性" class="headerlink" title="4.线程的属性"></a>4.线程的属性</h4><p><img src="/img/System/2.19.png"></p><h4 id="5-线程的实现方式"><a href="#5-线程的实现方式" class="headerlink" title="5.线程的实现方式"></a>5.线程的实现方式</h4><ul><li>线程的实现分为两类：用户级线程（User-Level Thread,UTL）和内核级线程（Kernel-Level Thread,KTL）。内核级线程又称内核支持的线程</li></ul><p>（1）用户级线程</p><p><img src="/img/System/2.20.png"></p><p>（2）内核级线程</p><p><img src="/img/System/2.21.png"></p><p>（3）特殊的组合方式及重点注意</p><p><img src="/img/System/2.22.png"></p><h4 id="6-多线程模型"><a href="#6-多线程模型" class="headerlink" title="6.多线程模型"></a>6.多线程模型</h4><p><img src="/img/System/2.23.png"></p><p><img src="/img/System/2.24.png"></p><p><img src="/img/System/2.25.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>System</tag>
      
      <tag>408考研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Instruction of Algorithm</title>
    <link href="/Algorithm/"/>
    <url>/Algorithm/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/AllAlgorithm.png" alt="《Instruction of Algorithm (Fourth Edition)》"></p><p><img src="/img/Algorithm2.png" alt="《算法导论》（第3版）"></p><div class="note note-warning">            <p>本文内容根据博主自身理解，同时结合《Instruction of Algorithm (4th Edition)》和《算法导论》（第三版）编写。</p><p>本书是利用 CPP 完成的语法编写内容，同时也是 CPP算法学习的一本书，内容以龙书中的算法开始学习，由浅入深，配合一些 CPP 的内容，完成算法的初步学习和理解。</p><p>PS：借鉴了很多原书中的内容，因为写的太好了……</p><p>本文章中，将上面两部书简称为‘龙书’</p>          </div><h2 id="Part-1-The-Role-of-Algorithms-in-Computing">Part 1 The Role of Algorithms in Computing</h2><h3 id="1-Algorithms">1. Algorithms</h3><p><strong>算法</strong>：（非形式的说）就是定义任何良定义的计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出。</p><p><code>Informally, an algorithm is any well-defined computational procedure that takes some value, or set of values, as input and produces some value, or set of values, as output in a finite amount of time.</code></p><p><strong>输入</strong></p><p><strong>输出</strong></p><h2 id="Part-2-Getting-Started">Part 2 Getting Started</h2><h3 id="Sort-Algorithm">Sort Algorithm</h3><p><a href="https://Polaris516.github.io/SortAlgorithm/">手撕排序算法</a></p><p><code>PS：这里的排序算法会用到后面的分治，递归等重要思想，可以提前了解一下排序算法，在后面的学习中，再次看排序算法你会收获更多。</code></p><h3 id="Binary-Search">Binary Search</h3><p><strong>二分查找：</strong></p><p>二分查找是一种在有序数组中快速查找目标值的算法，通过不断缩小搜索范围（每次排除一半的元素），时间复杂度为 O(log n)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> target)</span> </span>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br><span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">if</span>(nums[mid] == target) &#123;<br><span class="hljs-keyword">return</span> mid;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target) &#123;<br>left = mid + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>right = mid - <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>&#125;;<br>cout &lt;&lt; <span class="hljs-built_in">binarySearch</span>(nums, <span class="hljs-number">5</span>) &lt;&lt; endl;   <span class="hljs-comment">// ?? 2</span><br>cout &lt;&lt; <span class="hljs-built_in">binarySearch</span>(nums, <span class="hljs-number">9</span>) &lt;&lt; endl;   <span class="hljs-comment">// ?? 4</span><br>cout &lt;&lt; <span class="hljs-built_in">binarySearch</span>(nums, <span class="hljs-number">2</span>) &lt;&lt; endl;   <span class="hljs-comment">// ?? -1(???)</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 二分查找的前提条件就是数组必须有序（可以是从大到小或者从小到大，按照情况调节代码</span><br></code></pre></td></tr></table></figure><hr><h2 id="Part-3-The-Divide-And-Conquer-method">Part 3 The Divide-And-Conquer method</h2><p><code>The divide-and-conquer method</code>：they break the problem into several subproblems that are similar to the original problem  but smaller in size, solve the subproblems recursively, and  then combine these solutions to create a solution to the original problem. In the divide-and-conquer method, if the problem is small enough—the base case—you just solve it directly without recursing.</p><p><code>分治策略</code>：将原来的问题拆解成和原问题相同的子问题，规模上变小使得可以通过解决子问题，将答案整合变成原问题的解。</p><p><code>Divide</code>: the problem into one or more subproblems that are smaller instances of the same problem.</p><p><code>Conquer</code>: the subproblem solutions to form a solution to the original problem.</p><p><code>Combine</code>: the subproblem solutions to form a solution to the original problem.</p><p><code>分</code>：将问题拆分成一个或若干个子问题，子问题与原问题形式相同，规模更小。</p><p><code>治</code>：子问题的解就是原问题的部分解</p><p><code>合</code>：子问题的解合并即是原问题的解</p><p><strong>特点：</strong></p><blockquote><ol><li>子问题之间相互独立，无重叠</li><li>通常不需要存储中间结果，直接通过递归逐层解决</li><li>适用于分解后子问题规模均衡的场景</li></ol></blockquote><p>[^divide-and-conquer algorithms partition the problem into disjoint subproblems, solve the subproblems recursively, and the combine their solutions to solve the original problem. In contrast dynamic programming applies when the subproblems overlap-that is ,when subproblems share subproblem.  --DP(instructions)]:</p><hr><h2 id="Part-4-Dynamic-Programming">Part 4 Dynamic Programming</h2><p><code>Dynamic Programming</code> applies when the subproblems overlap-that is ,when subproblems share subproblem. A dynamic-programming algorithm solves each subproblem just once and then saves its answer in a table, thereby  avoiding the work of recomputing the answer every time if solves each subproblem.</p><p><code>动态规划</code>：DP适用于子问题重叠的情况–即共享子问题，动态规划将每次解决的子问题存储到一个表中，以免它被重复计算</p><blockquote><p>To develop a dynamic-programming algorithm, follow a sequence of four steps:</p><ol><li><p>Characterize the structure of an optimal solution.</p></li><li><p>Recursively define the value of an optimal solution.3. Compute the value of an optimal solution,typically in a bottom up fashion.</p></li><li><p>Construct an optimal solution from computed information.</p></li></ol></blockquote><h3 id="动态规划的核心思想：">动态规划的核心思想：</h3><ol><li>拆分问题：将大问题拆分成一个个的小问题</li><li>记录状态：每一个子问题得到的状态一般都记录在一个DP数组中，或者是通过栈、队列等其他方式去记录</li><li>DP无后效性，按照一定顺序去求解拆分后的小问题。当小问题的状态或者结果得到了之后，我们就不去关心它是怎样得到的</li></ol><h3 id="动态规划的解决方法（3-1）">动态规划的解决方法（3+1）</h3><ol><li>首先将一个大问题拆解成小问题，接下来确定每个小问题解决之后得到的结果表示什么，即<font color=red>确定每个小问题的状态</font>，例如费波纳茨数列中，DP[i] 表示前 i 个数的某种方法的个数。这里我们可以想象成多米诺骨牌，在多米诺骨牌中就是需要你清楚每张牌代表什么</li><li>确立每个状态之间的关系，在搭建多米诺骨牌的时候，你需要利用某种方法将其摆好，也就是可以保证它能够连续倒塌，这也就是问题中每个子问题中存在的联系——状态转移方程</li><li>确立初始状态，当你已经找到状态转移方程，完成你的多米诺骨牌，要让它开始完成倒下的任务时，你需要给他一个初始状态，也就是你需要推他一把，正如物理学中所讲，力不会平白无故出现，所以在DP问题中，你需要找到并且完成初始状态的分配，<font color = red>即确立边界条件</font></li><li>算法优化（目前先不涉及）</li></ol><h3 id="Surface-learning：">Surface-learning：</h3><p>下面我们通过几个浅显的例子，先来简单看看 DP 问题，然后通过龙书上面的内容，深入学习DP。</p><h4 id="0-1背包问题（简单理解——DP二维数组的内涵）">0-1背包问题（简单理解——DP二维数组的内涵）</h4><p>给你一个可装载容量为W的背包和N个物品，每个物品有重量和价值两个属性。其中第i个物品的重量为wt[i]，价值为va[i]，现在让你用这个背包装物品，最多能装的价值是多少?<br>在这里将问题具体化：现在有4 (N=4)个物品，背包总容量为8 (W=8),背包最多能装入价值为多少的物品?<br>物体编号物体体积物体价值<br>123<br>234<br>345<br>456</p><img src="D:/ProgramData/Myblog/source/_posts/assets/image-20240405225918312.png" alt="image-20240405225918312" style="zoom:50%;" /><hr><h2 id="Part-5-Greedy-Algorithms">Part 5 Greedy Algorithms</h2><p>贪心算法：是一种通过每一步选择当前局部最优解，最终希望达到全局最优解的算法设计思想。其核心在于每一步决策中不考虑未来可能的后果，只关注当下能做出的最优选择。</p><p><strong>核心思想：</strong></p><ol><li>局部最优选择：每一步选择当前状态下看起来最好的决策（无需考虑后续影响）</li><li>无后效性：一旦做出选择，后续的子问题仅基于当前状态，不受之前决策的影响</li><li>期望全局最优：通过一系列局部最优选择，希望最终得到全局最优解（但需通过数学证明其正确性）</li></ol><p><strong>关键特征：</strong></p><ul><li>贪心选择性质：每一步的局部最优选择能导致全局最优解</li><li>最优子结构：问题的最优解包含其子问题的最优解（与动态规划类似，但无需存储中间状态）</li></ul><p><a href="https://www.luogu.com.cn/problem/P1031">NOIP 2002 提高组] 均分纸牌 - 洛谷</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这道题只是简单理解一下贪心的过程：在这道题中什么是贪心呢？当然就是不管全局什么情况，当前位置下的那个数它必须是平均数：也就是说局部最优，问题中清晰的描述最后的排列肯定是N个数的值相同，这样我们求出平均数，只要保证当前位置的数是平均数即可。</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; number;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> N,avg;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>,cnt = <span class="hljs-number">0</span>,prefix = <span class="hljs-number">0</span>;<br>   <br>    cin &gt;&gt; N;<br>    number.<span class="hljs-built_in">resize</span>(N + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)&#123;<br>        cin &gt;&gt; number[i];<br>        sum += number[i];<br>    &#125;<br>    <br>    avg = sum / N; <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)&#123;<br>prefix += number[i] - avg; <span class="hljs-comment">// 这里我们模拟了一个牌堆，也就是说需要牌的时候，就跟牌堆要牌，多余牌就往牌堆扔牌，要注意扔牌和借牌都算是一种移动，想一下，正常情况下只能左右移动的时候，移出和移入都个算是一步。</span><br>        <span class="hljs-keyword">if</span>(prefix != <span class="hljs-number">0</span> &amp;&amp; i &lt; N - <span class="hljs-number">1</span>)&#123;<br>cnt++;<span class="hljs-comment">// 若牌堆不为0则我们由题可知肯定没结束，但是某些情况下在未完成任务就出现了prefix为0的情况，这样我们还需要设置另一个附加条件即当前位置不是倒数第二</span><br>        &#125;<br>    &#125;<br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 这里我们想一想：题目给出的是只能相邻移动，那如果是可以任意移动呢？</span><br><span class="hljs-comment">// 相邻移动: 你往牌堆扔牌和取牌个是一步</span><br><span class="hljs-comment">// 任意移动：你不用往牌堆扔牌，你直接扔给缺牌的即可</span><br></code></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P1208">USACO1.3] 混合牛奶 Mixing Milk - 洛谷</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Farmer</span> &#123;<br><span class="hljs-type">int</span> price;<br><span class="hljs-type">int</span> output;<br>&#125;;<span class="hljs-comment">// 定义结构体以及结构体属性</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> Farmer &amp;a, <span class="hljs-type">const</span> Farmer &amp;b)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(a.price != b.price) <span class="hljs-keyword">return</span> a.price &lt; b.price;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.output &gt; b.output;<br>&#125;<span class="hljs-comment">// 重定义比较函数</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> required,number;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><br>cin &gt;&gt; required &gt;&gt; number;<br><span class="hljs-function">vector&lt;Farmer&gt; <span class="hljs-title">farmers</span><span class="hljs-params">(number)</span></span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++) &#123;<br>cin &gt;&gt; farmers[i].price &gt;&gt; farmers[i].output;<br>&#125;<br><span class="hljs-built_in">sort</span>(farmers.<span class="hljs-built_in">begin</span>(),farmers.<span class="hljs-built_in">end</span>(),cmp);<br><br><span class="hljs-type">int</span> remaining = required;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; number &amp;&amp; remaining &gt; <span class="hljs-number">0</span>; ++j) &#123;<br><span class="hljs-type">int</span> buy = <span class="hljs-built_in">min</span>(farmers[j].output,remaining);<br>sum += buy * farmers[j].price;<br>remaining -= buy;<br>&#125; <span class="hljs-comment">// 利用min函数可以省去一些计算过程，然后求值即可，因为你的价格已经按照从低到高完成排序</span><br><br>cout &lt;&lt; sum &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 本题的贪心思路：若优先购买价格低的牛奶，由于总量不变，故局部最优累计可以达到全局最优效果。</span><br></code></pre></td></tr></table></figure><blockquote><p>在这里我们可以看到一个基本的贪心思路：</p><ul><li>定义一个结构体，确定该结构体的属性</li><li>在某些贪心思路下，对结构体中的属性按照要求完成排序（这里可以直接使用<algorithm>里面的 sort 完成排序，我们只要完成它里面的比较函数的逻辑编写）</li><li>按照题目所说完成算法</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">push_back</span>() 在Vector最后添加一个元素（参数为要插入的值）<br></code></pre></td></tr></table></figure><hr><h2 id="Part-6-Elementary-Graph-Algorithms">Part 6 Elementary Graph Algorithms</h2><h3 id="Breadth-first-search">Breadth-first search</h3><p>**核心思想：**BFS是一种逐层遍历的算法，从起点出发，先访问所有距离为1的节点，再访问所有距离为2的节点，以此类推。适合解决最短路径问题。</p><blockquote><p>算法步骤：</p><ol><li>初始化队列，将起点加入队列并标记为已访问</li><li>从队列中取出一个节点，访问其所有未访问的邻接节点，将它们加入队列并标记</li><li>重复步骤2直至队列为空</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp;graph)</span></span>&#123;<br><span class="hljs-type">int</span> V = graph.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(V,<span class="hljs-literal">false</span>)</span></span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <br>    visited[start] = <span class="hljs-literal">true</span>;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cout &lt;&lt; u &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:graph[u])&#123;<br>            <span class="hljs-keyword">if</span>(!visited[v])&#123;<br>                visited[v] = <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(v);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>     <span class="hljs-comment">// 图的邻接表表示（5个节点）</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph = &#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,     <span class="hljs-comment">// 节点0的邻居</span><br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,  <span class="hljs-comment">// 节点1的邻居</span><br>        &#123;<span class="hljs-number">0</span>&#125;,        <span class="hljs-comment">// 节点2的邻居</span><br>        &#123;<span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 节点3的邻居</span><br>        &#123;<span class="hljs-number">1</span>&#125;         <span class="hljs-comment">// 节点4的邻居</span><br>    &#125;;<br>    cout &lt;&lt; <span class="hljs-string">&quot;BFS遍历顺序（从节点0开始）：&quot;</span>;<br>    <span class="hljs-built_in">BFS</span>(<span class="hljs-number">0</span>,graph); <span class="hljs-comment">// 输出：0 1 2 3 4</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Depth-first-search">Depth-first search</h3><p>**核心思想：**DFS是一种尽可能深的搜索算法，沿着一条路径走到尽头，然后回溯到最近未访问节点继续搜索。适合解决连通性问题、拓扑排序、回溯问题。</p><blockquote><p>算法步骤：（递归）</p><ol><li>从起点出发，标记为已访问</li><li>递归访问当前结点的所有未访问邻接节点</li><li>回溯到上一个节点继续搜索</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph,vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span></span>&#123;<br>visited[u] = <span class="hljs-literal">true</span>;<br>    cout &lt;&lt; u &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:graph[u])&#123;<br>        <span class="hljs-keyword">if</span>(!visited[v])&#123;<br>            <span class="hljs-built_in">DFS</span>(v,graph,visited);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-comment">// 图的邻接表表示（与BFS示例相同）</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph = &#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,     <span class="hljs-comment">// 节点0的邻居</span><br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,  <span class="hljs-comment">// 节点1的邻居</span><br>        &#123;<span class="hljs-number">0</span>&#125;,        <span class="hljs-comment">// 节点2的邻居</span><br>        &#123;<span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 节点3的邻居</span><br>        &#123;<span class="hljs-number">1</span>&#125;         <span class="hljs-comment">// 节点4的邻居</span><br>    &#125;;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(graph.size(), <span class="hljs-literal">false</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;DFS遍历顺序（从节点0开始）: &quot;</span>;<br>    <span class="hljs-built_in">DFS</span>(<span class="hljs-number">0</span>, graph, visited); <span class="hljs-comment">// 输出: 0 1 3 4 2 </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>EG：现在要求输入一个数字，然后对这个数字进行全排列并且输出出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; data;<br>vector&lt;<span class="hljs-type">bool</span>&gt; mark;<br><span class="hljs-type">int</span> end_position;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> pre_position)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(pre_position == end_position)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; end_position; i++)&#123;<br>            cout &lt;&lt; data[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= end_position; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!mark[i])&#123;<br>            mark[i] = <span class="hljs-literal">true</span>;<br>            data[pre_position] = i;<br>            <span class="hljs-built_in">DFS</span>(pre_position + <span class="hljs-number">1</span>);<br>            <br>            mark[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin &gt;&gt; end_position;<br>    data.<span class="hljs-built_in">resize</span>(end_position);        <span class="hljs-comment">// 提前分配存储空间</span><br>    mark.<span class="hljs-built_in">resize</span>(end_position + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// +1是为了能存放下标end_position</span><br>    <span class="hljs-built_in">DFS</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,k,result = <span class="hljs-number">0</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; nums;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= x; i++)&#123;<br>        <span class="hljs-keyword">if</span>(x % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 判断一个数是否为素数：对这个数进行循环取余，若在某值下取余为0，也就是说可以整除那么则说明不是素数。</span><br><span class="hljs-comment">// 对这个判断素数的算法进行优化，就是优化它的循环次数，若一个数不是素数，必存在一个因数对 (a,b) 满足 a ≤ √n 且 b ≥ √n。因此只需检查 2 ≤ i ≤ √n 的范围即可。</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> count,<span class="hljs-type">int</span> sum)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(count == k)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">is_prime</span>(sum))<br>            result++;<br>    <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start; i &lt; n; i++)&#123;<br>        <span class="hljs-built_in">DFS</span>(i + <span class="hljs-number">1</span>, count + <span class="hljs-number">1</span>, sum + nums[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    nums.<span class="hljs-built_in">resize</span>(n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        cin &gt;&gt; nums[i];<br>    &#125;<br>    <span class="hljs-built_in">DFS</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    cout &lt;&lt; result &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>其实通过代码可以总结一下DFS一些基本的规律：</p><ol><li>DFS目前其实就是由两部分组成：递归和跳出</li><li>递归：根据某些场景的需要，利用参数的不同来实现循环递归调用</li><li>跳出：当到达最深处或者是场景需求下的位置时，完成场景下的任务，跳出递归，返回到上一层级，继续递归，直至所有任务完成。</li></ol></blockquote><p>对于这两个例题的选择，我们可以发现有一个标记数组，这也就是去重，在DFS或者其他所有算法中进行优化的剪枝效果。</p><p><a href="https://www.luogu.com.cn/problem/P1135">P1135 奇怪的电梯 - 洛谷</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;climits&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> N,A,B;<br>vector&lt;<span class="hljs-type">int</span>&gt; K;<br>vector&lt;<span class="hljs-type">int</span>&gt; min_steps;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> current_floor,<span class="hljs-type">int</span> step)</span></span>&#123;<br><span class="hljs-keyword">if</span>(step &gt;= min_steps[current_floor])&#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125; <span class="hljs-comment">// 剪枝：若当前的步数已经大于最小步数，那么再往后在进行计算就没有必要</span><br>    <br>    min_steps[current_floor] = step;<br>    <span class="hljs-comment">// 向上走</span><br>    <span class="hljs-type">int</span> next_floor = current_floor + K[current_floor];<br>    <span class="hljs-keyword">if</span>(next_floor &lt;= N &amp;&amp; step + <span class="hljs-number">1</span> &lt; min_steps[next_floor])&#123;<br>        <span class="hljs-built_in">DFS</span>(next_floor,step + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 向下走</span><br>    next_floor = current_floor - K[current_floor];<br>    <span class="hljs-keyword">if</span>(next_floor &gt;= <span class="hljs-number">1</span> &amp;&amp; step + <span class="hljs-number">1</span> &lt; min_steps[next_floor])&#123;<br>        <span class="hljs-built_in">DFS</span>(next_floor,step  + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; N &gt;&gt; A &gt;&gt; B;<br>    <br>    K.<span class="hljs-built_in">resize</span>(N + <span class="hljs-number">1</span>);<br>    min_steps.<span class="hljs-built_in">resize</span>(N + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)&#123;<br>        cin &gt;&gt; K[i];<br>        min_steps[i] = INT_MAX;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(A == B)&#123;<br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-comment">// 特殊情况：起始值和结束值一样。</span><br>    <br>    <span class="hljs-built_in">DFS</span>(A,<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">if</span>(min_steps[B] != INT_MAX)&#123;<br>        cout &lt;&lt; min_steps[B] &lt;&lt; endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的深度搜索 + 剪枝很像 DP 的思想</p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
