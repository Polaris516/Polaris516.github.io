<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于Springboot + Scrapy + Vue的信息快检索平台</title>
    <link href="/DataWeb/"/>
    <url>/DataWeb/</url>
    
    <content type="html"><![CDATA[<p><code>本次博客内容先瞻：</code></p><span class="label label-primary">text</span>本次博客，我们要实现利用 Scrapy 框架对网站数据进行爬取后存储到MySQL数据库中，然后使用 Vue 写一个Web网站，最后利用 Springboot 框架编写后端接口，将数据库的内容渲染到网站，实现一个简单的信息快检索平台。]]></content>
    
    
    
    <tags>
      
      <tag>Springboot</tag>
      
      <tag>Vue</tag>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Compilers</title>
    <link href="/Compeilers/"/>
    <url>/Compeilers/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    
    <tags>
      
      <tag>Compilers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Organization</title>
    <link href="/ComputerOrganization/"/>
    <url>/ComputerOrganization/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><div class="note note-warning">            <p>本文是介绍计算机组成原理，覆盖408考点，但是着重点是以国外教材为主。</p>          </div><p>博客参考书籍：</p><h2 id="第一章-概论"><a href="#第一章-概论" class="headerlink" title="第一章 概论"></a>第一章 概论</h2><p><img src="/img/C-O/1.1.png"></p><h3 id="1-1-计算机发展历程"><a href="#1-1-计算机发展历程" class="headerlink" title="1.1 计算机发展历程"></a>1.1 计算机发展历程</h3><h4 id="1-1-1-计算机的软硬件的概念"><a href="#1-1-1-计算机的软硬件的概念" class="headerlink" title="1.1.1 计算机的软硬件的概念"></a>1.1.1 计算机的软硬件的概念</h4><p>计算机系统由“硬件”和“软件”两大部分组成。</p><p>​硬件：计算机的实体部分，它由看得见摸得着的各种电子元器件，各类光、电、机设备的实物组成，如主机，外部设备等。</p><p>​软件：它看不见摸不着，由人们事先编制的具有各类特殊功能的程序组成。</p><h4 id="1-1-2计算机的发展"><a href="#1-1-2计算机的发展" class="headerlink" title="1.1.2计算机的发展"></a>1.1.2计算机的发展</h4><table><thead><tr><th>发展阶段</th><th>时间</th><th>逻辑元件</th><th>速度（次&#x2F;秒）</th></tr></thead><tbody><tr><td>一代</td><td>1946 - 1957</td><td>电子管</td><td>几千~几万</td></tr><tr><td>二代</td><td>1958 - 1964</td><td>晶体管</td><td>几万~几十万</td></tr><tr><td>三代</td><td>1964 - 1971</td><td>中小规模集成电路</td><td>几十万~几百万</td></tr><tr><td>四代</td><td>1972 - 今</td><td>大规模和超大规模集成电路</td><td>上千万~万亿</td></tr></tbody></table><p><strong>摩尔定律：</strong>集成电路上的晶体管数量每18个月就会翻一番，所以每18个月计算机的处理效率就会提高一倍。</p><blockquote><p>晶体管之父：肖克利（1956年诺贝尔物理学奖得主）</p><p>1957年，“八叛徒”创立了仙童半导体</p><p>1959年，仙童半导体发明了“集成电路”</p><p>1968年，摩尔离开仙童，创立intel</p><p>1969年，仙童销售部负责人桑德斯离开仙童，创立AMD</p></blockquote><h4 id="1-1-3-计算机的分类和发展方向"><a href="#1-1-3-计算机的分类和发展方向" class="headerlink" title="1.1.3 计算机的分类和发展方向"></a>1.1.3 计算机的分类和发展方向</h4><ul><li>电子模拟计算机和电子数字计算机<ul><li>电子数字计算机按用途分为2类：专用计算机、通用计算机<ul><li>通用计算机：巨型机、大型机、中型机、小型机、微型机和单片机6类</li></ul></li><li>按照指令和数据流分为：<ul><li>单指令流和单数据流系统（SISD），即传统的冯·诺依曼体系结构</li><li>单指令流和多数据流系统（SIMD），包括阵列处理器和向量处理器系统</li><li>多指令流和单数据流系统（MISD），这种计算机实际上不存在</li><li>多指令流和多数据流系统（MIMD），包括多处理器和计算机系统</li></ul></li></ul></li></ul><h3 id="1-2-计算机系统的层次结构"><a href="#1-2-计算机系统的层次结构" class="headerlink" title="1.2 计算机系统的层次结构"></a>1.2 计算机系统的层次结构</h3><p><strong>五个层级 三种语言 两种程序</strong></p><p><img src="/img/C-O/1.2.1.png"></p><h4 id="1-2-1-计算机系统的组成"><a href="#1-2-1-计算机系统的组成" class="headerlink" title="1.2.1 计算机系统的组成"></a>1.2.1 计算机系统的组成</h4><p>计算机系统由硬件系统和软件系统共同构建起来</p><h4 id="1-2-2-计算机硬件的基本构成"><a href="#1-2-2-计算机硬件的基本构成" class="headerlink" title="1.2.2 计算机硬件的基本构成"></a>1.2.2 计算机硬件的基本构成</h4><h5 id="1-早期的冯·诺依曼机"><a href="#1-早期的冯·诺依曼机" class="headerlink" title="1.早期的冯·诺依曼机"></a>1.早期的冯·诺依曼机</h5><blockquote><p>美籍匈牙利科学家冯·诺依曼最先提出“程序存储”的思想，并成功将其运用在计算机的设计之中，根据这一原理制造的计算机被称为冯·诺依曼结构计算机。由于他对现代计算机技术的突出贡献，因此冯·诺依曼又被称为“现代计算机之父”。</p><p><font color=blue>什么是存储程序原理？按此原理，计算机应具有哪几大功能？</font></p><p><font color=red>“程序存储”</font>：指令以代码的形式事先输入到计算机的主存储器中，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他程序，直至程序执行结束，即<font color="red">按地址访问并顺序执行指令</font></p><p>计算机按照此原理应具有5大功能：数据传送功能、数据存储功能、数据处理功能、操作控制功能、操作判断功能</p></blockquote><ul><li>冯·诺依曼体系结构特点<ol><li>计算机硬件系统由五大部件构成（存储器，运算器，控制器，输入设备，输出设备）</li><li>指令和数据以同等地位存于存储器，可按地址寻访</li><li>指令和数据用二进制表示</li><li>指令由操作码和地址码组成</li><li>存储程序</li><li>以运算器为中心</li></ol></li></ul><blockquote><p>早期的冯·诺依曼机以运算器为中心，且是单处理机，最根本的特征是采用“存储程序”原理，基本工作方式是<strong>控制流驱动方式</strong></p></blockquote><p><img src="/img/C-O/1.2.2.png"></p><h5 id="2-现代计算机的组织结构"><a href="#2-现代计算机的组织结构" class="headerlink" title="2.现代计算机的组织结构"></a>2.现代计算机的组织结构</h5><p><img src="/img/C-O/1.2.3.png"></p><h5 id="3-计算机的功能部件"><a href="#3-计算机的功能部件" class="headerlink" title="3.计算机的功能部件"></a>3.计算机的功能部件</h5><p>主机：主存、运算器、控制器</p><p><img src="/img/C-O/1.2.4.png"></p><p>五大部分：</p><ol><li><p>输入设备：是指将外部信息以计算机能读懂的方式输入进来，如键盘，鼠标等</p></li><li><p>输出设备：就是将计算机处理的信息以人所能接受的方式输出出来，比如显示屏，打印机</p></li><li><p>存储器，存储器主要分为<strong>主存储器</strong>（内存储器，CPU能直接访问）和<strong>辅助存储器</strong>（外存储器，协助主存储器记忆更多的信息，辅助存储器的信息需要导入到主存储器中，才能被CPU访问。</p><ul><li><strong>主存储器</strong>的工作方式是<font color=red>按存储单元的地址进行存取</font>，这种存取方式称为<strong>按地址存取方式</strong>（相联存储器既可以按照<strong>地址寻址</strong>，又可以按照<strong>内容寻址</strong>，为了与传统存储器区别，又称为<strong>内容寻址的存储器</strong>。</li><li>主存储器是由地址寄存器（MAR），数据寄存器（MDR），存储体，时序控制逻辑，地址寄存器存放访存地址，经过地址译码后找到所选的存储单元。数据寄存器，是存储器与其他部件的中介，用于暂存要从存储器读或写的信息。时序控制逻辑用于产生存储器操作所需的各种时序信号。在现代CPU中，MAR和MDR是在CPU中的。</li></ul><p> <img src="/img/C-O/1.2.5.png"></p></li><li><p>运算器：是计算机的运算单元，用于算数运算和逻辑运算，运算器的核心单元是算术逻辑单元（ALU）</p><p> <img src="/img/C-O/1.2.6.png"></p></li><li><p>控制器：是计算机的指挥中心，有其指挥各部件自动协调的进行工作，现代计算机将运算器和控制器集成到一个芯片上，合成中央处理器，简称CPU。有程序计数器（PC）、指令寄存器（IR）和控制单元（CU）</p><p> <img src="/img/C-O/1.2.7.png"></p></li></ol><p><font color=bule>一般将运算器和控制器集成到同一个芯片上，称为<strong>中央处理器（CPU）</strong>。<strong>CPU</strong>和<strong>主存储器</strong>共同构成主机，而除主机外的其他硬件装置（外存，I&#x2F;O设备等）统称为外部设备，即<strong>外设</strong>。</font></p><p>CPU和主存之间通过一组<strong>总线</strong>相连，总线中有<strong>地址、控制和数据3组信号线</strong>。MAR中的地址信息会直接送到地址线上，用于指向读&#x2F;写操作的主存存储单元；控制线中有读&#x2F;写信号线，指出数据是从CPU写入主存还是从主存读出到CPU，根据是读操作还是写操作来控制将MDR中的数据直接送到数据线上还是将数据线上的数据接收到MDR中。</p><h3 id="1-3-计算机软件的分类"><a href="#1-3-计算机软件的分类" class="headerlink" title="1.3 计算机软件的分类"></a>1.3 计算机软件的分类</h3><p>计算机软件，一般分为系统软件和应用软件</p><ul><li>系统软件包括 操作系统、数据库管理系统、语言处理系统（比如编译器）、分布式软件系统、网络软件系统、标准库系统、服务性系统（比特连接程序）</li><li>应用软件包括各种科学计算类程序，工程设计类程序，数据统计与处理程序</li></ul><p>注意：数据库管理系统和数据库系统是有区别的。数据库管理系统是系统软件。而数据库系统一般是由数据库，数据库管理系统，数据库管理员和应用系统构成。所以只能说它里面有系统软件，但并不能说它为系统软件。</p><p>2.三个级别的语言</p><ul><li>机器语言。又称二进制代码语言，需要编程人员记忆每条指令的二进制编码。<strong>机器语言是计算机唯一可以直接识别和执行的语言。</strong></li><li>汇编语言。汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编语言编辑的程序，必须经过一个称为汇编程序的系统软件的翻译，将其转换为计算机的机器语言后，才能在计算机的硬件系统上执行。</li><li>高级语言。高级语言(如C、C++、Java等)是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。</li><li>由高级语言转换到汇编语言的过程叫做<strong>编译</strong>，由汇编语言转换到机器语言的过程叫做<strong>汇编</strong>，边翻译边执行的叫做<strong>解析</strong>。</li></ul><p>机器语言是<strong>唯一</strong>可以控制cpu的语言，因为它的符号不利于人识别和书写，为了方便理解和记忆，将机器语言换一些通俗易懂的符号，这就变成了汇编语言。一般来说在在编译器中高级语言先转换为汇编在转换为机器语言，也有直接转换为机器语言的情况。</p><blockquote><p><font color=green>机器语言是计算机唯一可以直接执行的语言</font>，汇编语言用助记符编写，以便记忆。而正则语言是编译原理中符合正则文法的语言。</p><p>解释程序的特点是翻译一句执行一句，边翻译边执行：由高级语言转化为汇编语言的过程叫编译，把汇编语言翻译成机器语言的过程叫汇编。</p></blockquote><p>IR存放当下欲执行的指令；PC存放下一条指令的地址；</p><p>MAR存放欲访问的存储单元地址；MDR存放从存储单元取来的数据</p><p>地址译码器是主存的构成部分，不属于CPU；地址寄存器虽然一般属于主存，但是现代计算机中绝大多数CPU内集成了地址寄存器</p><p>关于CPU存取速度的比较：寄存器（CPU内部）&gt; Cache（高速的SRAM）&gt; 内存（SDRAM）</p><h3 id="1-4-计算机的性能指标"><a href="#1-4-计算机的性能指标" class="headerlink" title="1.4 计算机的性能指标"></a>1.4 计算机的性能指标</h3><p><img src="/img/C-O/1.3.1.png"></p><p><code>周期：1次需要多少s，频率：1s能完成多少次</code></p><p><strong>1.机器字长</strong>：</p><p>计算机的位数（机器字长），表示计算机一次整数运算（即定点整数运算）所能处理的二进制数据位数。计算机字长通常选定为（8位），通常是2,4,8倍。不同的计算机，字节可能不同</p><blockquote><p><font color=red>机器字长，指令字长，存储字长的区别和联系</font></p><ul><li>机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度</li><li>指令字长：一个指令字中包含的二进制代码的位数。</li><li><strong>存储字长</strong>：一个存储单元存储的二进制代码的长度。<strong>等于MDR的位数</strong>，他们都必须是字节的整数倍</li><li><strong>数据字长：数据总线一次能传送信息的位数，</strong>它可以不等于MDR的位数。</li></ul><p>指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令，因此取指周期为机器周期的2倍；若指令字长等于存储字长，则取指周期等于机器周期。</p><p>早期的计算机存储字长一般和机器的指令字长与数据字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍。</p><p>请注意64位操作系统是指特别为64位架构的计算机而设计的操作系统，它能够利用64位处理器的优势。但64位机器既可以使用64位操作系统，又可以使用32位操作系统。而32位处理器是无法使用64位操作系统的。</p></blockquote><p><strong>2.数据通路带宽</strong></p><p>数据总线一次所能传送信息的位数</p><p><strong>3.主存容量</strong></p><p>MAR的位数反映存储单元的个数，如MAR为16位，表示存储单元为$$2^{16} &#x3D; 64k$$;若MDR为32位，则存储容量为$$2^{16}*32 $$</p><p><strong>4.运算速度</strong></p><blockquote><p>吞吐量：指系统在单位时间内处理的请求；从用户观点看，它是评价计算机系统性能的综合参数</p><p>响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结构的等待时间</p></blockquote><blockquote><p>CPU时钟周期：通常为节拍脉冲或T周期，即主频的倒数，它是CPU中最小的时间单位，每个动作至少需要1个时钟周期。</p><p>主频（CPU时钟频率）：机器内部主时钟的频率，是衡量机器速度的重要参数。</p><ul><li>CPU周期又称为机器周期，由多个时钟周期组成</li><li>指令周期&gt;CPU周期&gt;时钟周期</li></ul></blockquote><blockquote><p><font color = red>CPI（Clock cycle Per Instruction)：即执行一条指令所需的时钟周期数</font></p></blockquote><blockquote><p>CPU执行时间，指运行一个程序所花费的时间</p><p><strong>CPU执行时间 &#x3D; CPU时钟周期&#x2F;主频 &#x3D; （指令条数 * CPI)&#x2F;主频</strong></p><p><strong>CPU的性能</strong>主要取决于三个因素：<strong>主频</strong>、<strong>CPI</strong>、<strong>指令条数</strong></p></blockquote><blockquote><p>IPS(Instructions Per Second) &#x3D;主频&#x2F;平均CPI，每秒执行多少指令</p><p>MIPS(Million Instructions Per Second)&#x3D;即每秒执行多少百万条指令。</p><p>MFLOPS(Mega Floating-point Operations Per Second)&#x3D;浮点操作次数&#x2F;(执行时间x106),即每秒执行多少百万次浮点运算。</p><p>GFLOPS(Giga Floating-point Operations Per Second)&#x3D;浮点操作次数&#x2F;(执行时间x109)，即每秒执行多少十亿次浮点运算。</p><p>TFLOPS(Tera Floating-point Operations Per Second)&#x3D;浮点操作次数&#x2F;(执行时间x1012)，即每秒执行多少万亿次浮点运算</p></blockquote><h2 id="第二章-数据的运算和表示"><a href="#第二章-数据的运算和表示" class="headerlink" title="第二章 数据的运算和表示"></a>第二章 数据的运算和表示</h2><p><img src="/img/C-O/2.1.png"></p><h3 id="2-1-数制与编码"><a href="#2-1-数制与编码" class="headerlink" title="2.1 数制与编码"></a>2.1 数制与编码</h3><h4 id="2-1进位计数制及其相互转化"><a href="#2-1进位计数制及其相互转化" class="headerlink" title="2.1进位计数制及其相互转化"></a>2.1进位计数制及其相互转化</h4><p><img src="/img/C-O/2.1.1.png"></p><p><strong>机器数：</strong>把符号“数字化”的数称为机器数</p><p><strong>真值</strong>：带“+”或”-“符号的数称为真值</p><p><strong>原码</strong>：符号位“0”表示正数，“1”表示负数，数值位即真值的绝对值</p><p><strong>反码</strong>：通常用来作为原码求补码，或补码求原码的中间过渡、正数反码就是正数</p><p><strong>补码</strong>：可以将减法操作化作加法操作。正数的补码是其本身, 负数的补码可以看作对其原码<strong>除符号位外, 每位求反, 末位加1。特别地, [x]补 经过符号位和数值位按位取反+1 得到[-x]补。</strong></p><p><strong>移码</strong>：针对补码无法直接比较大小而引出的一种表示法，即对补码加上一个$$2^n$$，即将最高位符号位取反</p><p><strong>除0</strong>：故障</p><p><strong>长字节转短字节</strong>：截断高位</p><p><strong>短字节转长字节</strong>：符号扩展</p><blockquote><p>备注: </p><pre><code class="hljs">1) 十进制小数不一定都能用二进制表示。2) 原码, 反码的表示在数轴上对称, 存在+0和-0；而补码, 移码的0是唯一的。3) 移码和补码的符号位相反, 数值位相同4) 负数的补码中, 数值部分越大, 真值越大(更靠近0), 多表示一个最小负数5) 移码保持数据原有大小顺序, 移码大则真值大6) 补码符号位可以参与运算</code></pre></blockquote><h4 id="2-2-定点数的表示和运算"><a href="#2-2-定点数的表示和运算" class="headerlink" title="2.2 定点数的表示和运算"></a>2.2 定点数的表示和运算</h4><h2 id="第三章-存储系统"><a href="#第三章-存储系统" class="headerlink" title="第三章 存储系统"></a>第三章 存储系统</h2><h2 id="第四章-指令系统"><a href="#第四章-指令系统" class="headerlink" title="第四章 指令系统"></a>第四章 指令系统</h2><h2 id="第五章-中央处理器"><a href="#第五章-中央处理器" class="headerlink" title="第五章 中央处理器"></a>第五章 中央处理器</h2><h2 id="第六章-总线"><a href="#第六章-总线" class="headerlink" title="第六章 总线"></a>第六章 总线</h2><h2 id="第七章-输入-输出系统"><a href="#第七章-输入-输出系统" class="headerlink" title="第七章 输入&#x2F;输出系统"></a>第七章 输入&#x2F;输出系统</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>《Computer Organization And Design RISC-V edition》<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>408</tag>
      
      <tag>Computer Organization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/Linux/"/>
    <url>/Linux/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AndroidApp</title>
    <link href="/AndroidApp/"/>
    <url>/AndroidApp/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-应用开发模式"><a href="#Android-应用开发模式" class="headerlink" title="Android 应用开发模式"></a>Android 应用开发模式</h1><div class="note note-primary">            <p>本内容结合博主自己开发Android App的经历，在这中间遇到很多的波折，将这些整理下来并且给予初学者一个帮助，本文将通过最简单的方式带你入门，并且独自开发一个app。</p>          </div><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>参考资料：《Android Sudio开发实践——从零基础到App上线》欧阳燊<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>参考内容：……<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>软件开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>System Operation</title>
    <link href="/System/"/>
    <url>/System/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-操作系统概述"><a href="#第一章-操作系统概述" class="headerlink" title="第一章 操作系统概述"></a>第一章 操作系统概述</h1><div class="note note-primary">            <p>本文主要针对408考研内容编写，以及Linux等操作。</p>          </div><h2 id="1-1-操作系统简介"><a href="#1-1-操作系统简介" class="headerlink" title="1.1 操作系统简介"></a>1.1 操作系统简介</h2><p><code>操作系统能做什么？</code></p><div class="note note-warning">            <ul><li>从用户的角度：<ol><li>提供良好的用户界面</li><li>标准的函数库</li><li>使得编程更加方便并且不容易出错</li></ol></li><li>从系统的角度：<ol><li>管理资源（硬件资源、处理机、存储器、设备；信息资源【文件】）</li><li>解决申请资源时产生的冲突</li><li>阻止错误的产生和计算机不正当的使用</li></ol></li></ul>          </div><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p><font color="red">操作系统（Operation System，OS）</font>：是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本你爹系统软件。</p><blockquote><ul><li><p>An operating system acts an intermediary between user of a computer and the computer</p><p>  hardware.</p><ul><li>操作系统充当计算机⽤⼾和计算机硬件之间的中介</li></ul></li><li><p>The purpose of an operating system is to provide an environment in which a user can execute</p><p>  programs in a convenient and efficient manner.</p><ul><li>操作系统的⽬的是提供⼀个⽤⼾可以⽅便和有效地执⾏程序的环境</li></ul></li><li><p>An operating system is software that manages the computer hardware.</p><ul><li>操作系统是管理计算机硬件的软件</li></ul></li></ul></blockquote><p><img src="/img/System/System_1.1.png" alt="现代计算机硬件结构"></p><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><div class="note note-success">            <p>这里的内容以及和下面的<strong>存储器</strong>，<strong>I&#x2F;O设备</strong>，<strong>总线</strong>等都是计算机组成原理中的重要内容，在本文中也是按照书中给的内容进行叙述。下面有链接可以查看具体的讲解。（部分内容已经脱离408考点，主要是知识扩展）</p>          </div><blockquote><p>处理器（中央处理器（Central Processing Unit）—— CPU）：</p><ul><li><p>CPU工作的基本周期是：提取指令，译码分析，执行指令。（接化发！<code>链接中有讲到</code>）</p></li><li><p>CPU内部包含若干寄存器</p><ul><li><p>通用寄存器：</p><p>  ​用来存放关键变量和中间结果。</p></li><li><p>专用寄存器：</p><ul><li><p>程序计数器（PC）：</p><p>  ​PC中保存下面要提取指令的内存地址。</p></li><li><p>栈指针寄存器：</p><p>  ​存放指向当前内存栈的顶端的指针；该栈中保存有关函数（过程）调用时的现场信息，包括输入参数、局部变量和未在寄存器中保存的临时变量。</p><p>  ​程序执行过程中调用的每个函数在栈中站有一个帧面。</p></li><li><p>程序状态字（PSW）：</p><p>  ​条件码位、CPU优先级、程序执行模式（<strong>用户态</strong>或者<strong>核心态</strong>）和各种其他控制位。</p><p>  ​在系统调用和I&#x2F;O中PSW起重要作用。</p></li></ul></li></ul></li><li><p>处理机执行状态——保护操作系统程序，防止收到用户程序的损害：</p><ul><li><p>用户态</p><p>  ​用户程序（各种应用程序、工具、例程等）在用户态下执行，它们权限较低，只能执行指令集中非特权指令。</p></li><li><p>核心态（系统态、管理态）</p><p>  ​处于核心态，有较高特权，可以执行所有指令，包括普通用户程序中不能使用的<strong>特权指令</strong>，从而能对<strong>所有寄存器</strong>和<strong>内存</strong>进行访问，以及<strong>启动I&#x2F;O操作</strong>等。</p></li></ul></li></ul><p></p></blockquote><p><a href="https://polaris516.github.io/CO_CPU">中央处理器——CPU</a></p><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><blockquote><p>存储器（memory）：按照速度、容量和成本划分，存储器系统构成一个层次结构。（如图1.2）</p><ul><li><p>顶层是CPU的内部寄存器，速度和CPU一样快，存取它们没有延迟。但成本高，容量小，通常小于1KB</p></li><li><p>高速缓存：</p><p>  ​当程序需要读取具体信息时，Cache硬件先查看它是否在Cache中，如果在其中（“命中”），就直接使用它；反之，就从内存中获取该信息，并把它放入Cache中。小于4MB</p></li><li><p>内存（主存）：</p><ul><li>存储器系统的主力，也称作RAM（随机存取存储器）</li><li>CPU可以直接存取内存及寄存器和Cache中的信息。</li><li>机器执行的指令及所用的数据必须先存放在内存及Cache和寄存器中。</li><li>内存中存放的信息是易失的，当机器电源被关闭后，内存中的信息就全部丢失了。</li></ul></li><li><p>磁盘（硬盘、辅助存储器或者辅存、外存）：</p><ul><li>对内存的扩展</li><li>磁盘上可以永久保留数据，容量特别大</li><li>磁盘上数据的存取速度低于内存存取速度</li></ul></li><li><p>磁带</p><ul><li>数据永久保存，容量很大，存取速度很慢，不适宜随机存取。</li><li>主要作为文件系统的后备，存放不常用的信息或用做系统间的传送信息的介质。</li></ul></li><li><p>其他存储器：如软盘，光盘（CD-ROM）、U盘等</p></li></ul></blockquote><p><img src="/img/System/1.2.1.png" alt="图1.2"></p><p><a href="https://polaris516.github.io/CO_Memory">存储器——Memory</a></p><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h3><blockquote><ul><li><p>控制器：</p><p>  ​控制器是I&#x2F;O设备的电子部分，它协调和控制一台或多台I&#x2F;O设备的操作，实现设备操作与整个系统操作的同步。</p></li><li><p>设备:</p><p>  ​本身的对外接口相当简单，实际上他们隐藏在控制器后面</p></li></ul><p>设备驱动程序：向控制器发布命令并接收其回答信息的软件。</p></blockquote><ul><li>存储器只是众多IO设备的一种，IO设备是计算机体系结构中种类最丰富的设备类型，而且它有着很强的扩展性</li><li>管理IO设备是操作系统非常重要的组成成分，操作系统中有一个专门的IO子系统负责完成这项工作。</li></ul><p><a href="https://polaris516.github.io/CO_I-O">I&#x2F;O设备</a></p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><blockquote><ul><li><p>数据总线：</p><p>  ​计算机各部件之间传送数据的通道，其宽度随字长而定</p><p>  ​数据总线是双向总线，即两个方向都能传送数据</p></li><li><p>地址总线：</p><p>  ​从CPU送来地址的地址线，它可以是存储器的地址，也可以是IO设备控制器中中控制寄存器或数据寄存器的地址</p></li><li><p>控制总线：</p><p>  ​在该线上出现的信号是各个模块之间传送数据时所需的全部控制信号</p></li></ul></blockquote><h3 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h3><p><img src="/img/System/1.2.2.png"></p><h4 id="1-并发："><a href="#1-并发：" class="headerlink" title="1.并发："></a>1.并发：</h4><p><code>并发</code>：两个或多个事件在同一个时间间隔内发生，这些事件在宏观上是同时发生的，在微观上是交替发生的，操作系统的并发性指系统中同时存在着多个运行的程序</p><p><code>并行</code>：两个或多个事件在同一个时刻发生</p><p>一个单核（CPU）同一时刻只能执行一个程序，因此操作系统会协调多个程序使他们交替进行（这些程序在宏观上是同时发生的，在微观上是交替进行的）</p><p>操作系统是伴随着“多道程序技术出现的”，因此操作系统和并发是一同诞生的</p><p>在如今的计算机中，一般都是多核CPU的，即在同一时刻可以并行执行多个程序。</p><h4 id="2-共享："><a href="#2-共享：" class="headerlink" title="2.共享："></a>2.共享：</h4><ul><li>资源共享即共享，是指系统中的资源可以<code>供内存中多个并发执行的进程</code>共同使用</li><li>共享分为两类：互斥共享和同时共享<ol><li>互斥共享<ul><li>计算机中的某个资源在一段时间内只能允许一个进程访问，别的进程没有使用权</li><li>临界资源（独占资源）：在一段时间内只允许一个进程访问，别的进程没有使用权</li><li>eg：QQ和微信视频，同一段时间内摄像头只能分配给其中一个进程</li></ul></li><li>同时共享<ul><li>计算机中的某个资源在一段时间内可以同时允许多个进程访问</li><li>同时共享通常要求一个请求分为几个时间片段间隔的完成，即交替进行，“分时共享”</li><li>这里的同时指在宏观上是同时的，在微观上是交替进行访问的，只是CPU处理速度很快，我们感觉不到。在宏观上感觉是在同时进行</li><li>eg：比如QQ在发送文件A，微信在发送文件B，宏观上两个进程A和B都在访问磁盘，在我们看来是同时进行的，但是在微观上两个进程A和B是交替进行的，只是时间太短，cpu处理速度太快，我们感觉不到。</li><li><code>注意</code>：有时候多个进程可能真的是在同时进行资源访问，比如玩游戏时可以放音乐，游戏声音和音乐声音都能听见</li></ul></li></ol></li></ul><h4 id="3-并发和共享的关系"><a href="#3-并发和共享的关系" class="headerlink" title="3.并发和共享的关系"></a>3.并发和共享的关系</h4><p>并发性指计算机系统中同时存在着多个运行着的程序</p><p>共享性是指系统中的资源可供内存中多个并发执行的进程共同使用</p><ul><li>从上述例子来看二者之间的关系：<ol><li>两个进程正在并发执行（并发性）</li><li>需要共享地访问硬盘资源（共享性）</li></ol></li></ul><p><code>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义</code></p><p><code>如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发</code></p><h4 id="4-虚拟"><a href="#4-虚拟" class="headerlink" title="4.虚拟"></a>4.虚拟</h4><blockquote><p>多道程序设计：是指在计算机内存中同时存放几道互相独立的程序，使它们在管理程序控制之下，相互穿插的运行。两个或两个以上的程序在计算机系统中同处于开始到结束之间的状态。这就称为多道程序设计。多道程序技术运行的特征：多道、宏观上并行、微观上串行。</p></blockquote><ul><li>虚拟是把一个物理上的实体变为若干逻辑上的对应物</li><li>物理实体（前者）是实际存在的；而后者是虚的，是用户感觉上的事务</li><li>虚拟技术：用于实现虚拟的技术</li><li>虚拟处理器（CPU）：通过多道程序设计技术，采用让多道程序并发执行的方法，分时来使用一个CPU，实际物理上只有一个CPU，但是用户感觉到有多个CPU</li><li>虚拟存储器：从逻辑上扩充存储器容量，用户感觉到的但实际不存在的存储器</li><li>虚拟设备：将一台物理设备虚拟为逻辑上的多台设备，使多个用户在同一时间段内访问同一台设备，即同时共享，用户宏观上感觉是同时的，但实际上是微观交替访问同一台设备</li><li>操作系统的虚拟技术可归纳为：<ul><li>时分复用技术：如处理器的分时共享</li><li>空间复用技术：如虚拟处理器</li></ul></li></ul><p><code>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此没有并发性，就谈不上虚拟性</code></p><h4 id="5-异步"><a href="#5-异步" class="headerlink" title="5.异步"></a>5.异步</h4><ul><li>异步：多道程序环境允许多个程序并发执行，但由于资源有限，如cpu只有一个，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进。</li><li>比如A进程正在占用CPU计算，B进程这时也想占用CPU计算，B进程只有等，等A进程算完了，A进程去访问磁盘资源了，这时B进程再占用CPU进行计算，B进程还没计算完，A进程从磁盘取出资源了，A进程发现B这时在占用CPU，这时A进程就需要等待，等B算完后再继续到CPU中进行计算。由于每个进程占用资源的时间不固定，所以进程的执行以不可预知的速度前进</li></ul><h2 id="1-2-处理器系统"><a href="#1-2-处理器系统" class="headerlink" title="1.2 处理器系统"></a>1.2 处理器系统</h2><p><img src="/img/System/1.3.1,png"></p><h3 id="单处理器系统"><a href="#单处理器系统" class="headerlink" title="单处理器系统"></a>单处理器系统</h3><ul><li>Single-progress System</li><li>只有一颗注CPU，执行通用指令集</li><li>带有其他专用处理器，为特定设备服务，如：磁盘、键盘、图形控制器等<ul><li>它们能够执行的指令有限，不处理用户进程</li><li>操作系统会向它们发出任务，并监控它们的状态</li></ul></li></ul><h3 id="多处理器系统"><a href="#多处理器系统" class="headerlink" title="多处理器系统"></a>多处理器系统</h3><ul><li>Multi processor&#x2F;Muliticore System</li><li>有两个或多个紧密通信的CPU，它们共享计算机总线、时钟、内存和外设等。</li></ul><h3 id="集群系统"><a href="#集群系统" class="headerlink" title="集群系统"></a>集群系统</h3><ul><li>Clustered System</li><li>该系统由若干节点（Node）通过网络连接在一起，每个节点可为单处理器系统或多处理器系统，节点之间是松耦合（loosely coupled)关系<ul><li>高可用性（high availability）</li><li>高性能计算（high-performance computing)</li></ul></li></ul><h3 id="单道单用户模式"><a href="#单道单用户模式" class="headerlink" title="单道单用户模式"></a>单道单用户模式</h3><p><img src="/img/System/1.3.png" alt="单道单用户模式"></p><h3 id="多道程序设计"><a href="#多道程序设计" class="headerlink" title="多道程序设计"></a>多道程序设计</h3><ul><li>操作系统最重要的一点是具有多道程序的能力</li><li>单道程序不能让CPU和IO设备始终忙碌，多道程序设计通过安排任务使用的CPU总有一个执行任务，从而提高CPU利用率</li><li>实现的硬件保证：处理器和IO设备具有并行工作的能力</li></ul><h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><ul><li>分时系统也称多任务系统，是多道程序设计的自然延伸</li><li>允许多个用户共享一台计算机<ul><li>用户只有输入和输出设备</li><li>分时系统为每个用户轮流分配等量的CPU时间</li><li>用户从发出指令得到得到即时结果的时间称为响应时间</li></ul></li><li>第一个分时系统CTSS由MIT于1962年开发出来</li></ul><h2 id="1-3-操作系统的发展历程："><a href="#1-3-操作系统的发展历程：" class="headerlink" title="1.3 操作系统的发展历程："></a>1.3 操作系统的发展历程：</h2><p><img src="/img/System/1.3.2.png"></p><h2 id="1-4-操作系统的运行机制和体系结构"><a href="#1-4-操作系统的运行机制和体系结构" class="headerlink" title="1.4 操作系统的运行机制和体系结构"></a>1.4 操作系统的运行机制和体系结构</h2><h3 id="1-4-1-操作系统的运行机制和体系结构"><a href="#1-4-1-操作系统的运行机制和体系结构" class="headerlink" title="1.4.1 操作系统的运行机制和体系结构"></a>1.4.1 操作系统的运行机制和体系结构</h3><h4 id="1-操作系统的运行机制和体系结构"><a href="#1-操作系统的运行机制和体系结构" class="headerlink" title="1.操作系统的运行机制和体系结构"></a>1.操作系统的运行机制和体系结构</h4><p><img src="/img/System/1.5.1.png"></p><h4 id="2-操作系统体系结构类比"><a href="#2-操作系统体系结构类比" class="headerlink" title="2.操作系统体系结构类比"></a>2.操作系统体系结构类比</h4><p>类比：</p><p>操作系统体系结构问题与企业的管理问题很相似。</p><p>内核就是企业的管理层，负责一些重要的工作。只有管理层才能执行特权指令，普通员工只能执行非特权指令。用户态，核心态之间的切换相当于普通员工和管理层之间的工作交接</p><p>大内核：企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高；缺点是组织结构混乱，难以维护</p><p>微内核：随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护；缺点是效率低</p><h4 id="3-操作系统用户态和核心态的转换"><a href="#3-操作系统用户态和核心态的转换" class="headerlink" title="3.操作系统用户态和核心态的转换"></a>3.操作系统用户态和核心态的转换</h4><p>“用户态 -&gt; 核心态”是通过中断实现的。并且中断是唯一途径。“核心态 -&gt; 用户态”的切换是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”</p><h3 id="1-4-2-中断和异常"><a href="#1-4-2-中断和异常" class="headerlink" title="1.4.2 中断和异常"></a>1.4.2 中断和异常</h3><p><img src="/img/System/1.5.2.png"></p><p> 中断</p><ul><li>当有事件（event）发生时，CPU会收到一个中断（interrupt）信号，可以是硬中断也可以是软中断</li><li>CPU会停下正在做的事，转而执行中断处理程序，执行完毕会回到之前被中断的地方继续执行</li><li>Operation System is an Interrupt driven system<ul><li>操作系统是一个由中断驱动的系统</li></ul></li></ul><h3 id="1-4-3-系统调用（执行过程、访管指令、库函数与系统调用）"><a href="#1-4-3-系统调用（执行过程、访管指令、库函数与系统调用）" class="headerlink" title="1.4.3 系统调用（执行过程、访管指令、库函数与系统调用）"></a>1.4.3 系统调用（执行过程、访管指令、库函数与系统调用）</h3><p><img src="/img/System/1.4.3.png"></p><h1 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h1><h2 id="2-1-进程与线程"><a href="#2-1-进程与线程" class="headerlink" title="2.1 进程与线程"></a>2.1 进程与线程</h2><h3 id="1-进程的定义"><a href="#1-进程的定义" class="headerlink" title="1.进程的定义"></a>1.进程的定义</h3><h4 id="1-程序的概念"><a href="#1-程序的概念" class="headerlink" title="1.程序的概念"></a>1.程序的概念</h4><p>程序：就是一个指令序列</p><h4 id="2-进程的概念（引入多道程序技术之后）"><a href="#2-进程的概念（引入多道程序技术之后）" class="headerlink" title="2.进程的概念（引入多道程序技术之后）"></a>2.进程的概念（引入多道程序技术之后）</h4><ul><li>为了方便操作系统管理，完成各程序并发执行，引入了进程，进程实体的概念</li><li>PCB、程序段、数据段三部分构成了进程实体（进程映像）</li></ul><blockquote><p><font color =orange>进程和程序的区别与联系：</font></p><ol><li><p>进程是动态的，程序是静态的</p></li><li><p>进程有独立性，能并发执行，程序不能并发执行</p></li><li><p>二者无一一对应关系</p></li><li><p>进程异步运行，会相互制约；程序不具备此特征</p><p> 但是，进程和程序又有密切的联系：进程不能脱离具体程序而虚设，程序规定了相应进程所要完成的动作。</p></li><li><p>组成不同：进程包含PCB、程序段、数据段。程序包含数据和指令代码。</p></li><li><p>程序是一个包含了所有指令和数据的静态实体。本身除占用磁盘的存储空间外，并不占用系统如CPU、内存等运行资源。</p></li><li><p>进程由程序段、数据段和PCB构成，会占用系统CPU、内存等运行资源。</p></li><li><p>一个程序可以启动多个进程来共同完成</p></li></ol><p><font color=red>联系：进程不能脱离具体程序而虚设，程序规定了相应进程所要完成的动作。</font></p></blockquote><h4 id="3-进程的定义"><a href="#3-进程的定义" class="headerlink" title="3.进程的定义"></a>3.进程的定义</h4><p>程序段、数据段、PCB三部分组成了进程实体（进程映像）。一般情况下，我们把进程实体就简称为<strong>进程</strong>，例如，所谓创建进程，实质上是创建进程实体中的PCB，而撤销进程，实质上是撤销进程实体中的PCB。</p><p><font color=blue>PCB是进程存在的唯一标志</font></p><p>从不同角度，进程可以有不同的定义，比较传统典型的定义有：</p><ol><li>进程是程序的一次执行过程</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li><li>进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li></ol><p>引入进程实体的概念后，可以把进程定义为：</p><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p><p><font color=red>严格来说，进程和进程实体并不一样，进程实体是静态的，进程则是动态的。不过，除非题目专门考察二者的区别，否则可以认为进程实体就是进程，因此我们也可以说进程实体是由程序段、数据段、PCB三部分组成的。</font></p><h3 id="2-进程的特征"><a href="#2-进程的特征" class="headerlink" title="2.进程的特征"></a>2.进程的特征</h3><p><img src="/img/System/2.1.png"></p><h3 id="3-进程的组成"><a href="#3-进程的组成" class="headerlink" title="3.进程的组成"></a>3.进程的组成</h3><p><strong>PCB（Process Control Block）进程控制块：</strong></p><ul><li><p>PCB中记录了操作系统所需的，用于描述进程的当前情况以及控制进程运行的全部信息。</p><p>  ​PCB的作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位，一个能与其他进程并发运行的进程。</p><p>  ​或者说：<font color=purple>OS是根据PCB对并发执行的进程进行控制和管理的</font></p><p>  ​例如，当OS要<code>调度</code>某进程执行时，要从该进程的PCB中查处其现行状态及优先级；在调度某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据；</p><p>  ​进程在执行过程中，当需要和与之合作的进程实现同步，通信或者访问文件时，也都需要访问PCB；</p><p>  当进程由于某种原因而暂停执行时，又须将器断点的处理机环境保存在PCB中</p><p>  ​可见，在进程的整个生命期中，系统总是通过PCB对进程进行控制的，即系统是根据进程的PCB而不是任何别的什么而感知到该进程的存在的。</p><p>  ​所以说，PCB是进程存在的唯一标志。</p></li></ul><p><img src="/img/System/2.2.png"></p><h3 id="4-进程的组织"><a href="#4-进程的组织" class="headerlink" title="4.进程的组织"></a>4.进程的组织</h3><p>在一个系统中，通常有数十，数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。</p><p><font color = green>进程的组成讨论是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题</font></p><p><img src="/img/System/2.3.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>System</tag>
      
      <tag>408考研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Instruction of Algorithm</title>
    <link href="/Algorithm/"/>
    <url>/Algorithm/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/AllAlgorithm.png" alt="《Instruction of Algorithm (Fourth Edition)》"></p><p><img src="/img/Algorithm2.png" alt="《算法导论》（第3版）"></p><div class="note note-warning">            <p>本文内容根据博主自身理解，同时结合《Instruction of Algorithm (4th Edition)》和《算法导论》（第三版）编写。</p><p>PS：借鉴了很多原书中的内容，因为写的太好了……</p>          </div><h2 id="Part-1-The-Role-of-Algorithms-in-Computing"><a href="#Part-1-The-Role-of-Algorithms-in-Computing" class="headerlink" title="Part 1 The Role of Algorithms in Computing"></a>Part 1 The Role of Algorithms in Computing</h2><h3 id="1-Algorithms"><a href="#1-Algorithms" class="headerlink" title="1. Algorithms"></a>1. Algorithms</h3><p><strong>算法</strong>：（非形式的说）就是定义任何良定义的计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出。</p><p><code>Informally, an algorithm is any well-defined computational procedure that takes some value, or set of values, as input and produces some value, or set of values, as output in a finite amount of time.</code></p><p><strong>输入</strong></p><p><strong>输出</strong></p><h2 id="Part-2-Getting-Started"><a href="#Part-2-Getting-Started" class="headerlink" title="Part 2 Getting Started"></a>Part 2 Getting Started</h2><p><a href="https://polaris516.github.io/SortAlgorithm/">手撕排序算法</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
