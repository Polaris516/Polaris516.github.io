

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="启明星_Polaris">
  <meta name="keywords" content="">
  
    <meta name="description" content="本文内容根据博主自身理解，同时结合《Instruction of Algorithm (4th Edition)》和《算法导论》（第三版）编写。本书是利用 CPP 完成的语法编写内容，同时也是 CPP算法学习的一本书，内容以龙书中的算法开始学习，由浅入深，配合一些 CPP 的内容，完成算法的初步学习和理解。PS：借鉴了很多原书中的内容，因为写的太好了……本文章中，将上">
<meta property="og:type" content="article">
<meta property="og:title" content="Instruction of Algorithm">
<meta property="og:url" content="http://polaris516.github.io/Algorithm/index.html">
<meta property="og:site_name" content="一个程序员的简单博客">
<meta property="og:description" content="本文内容根据博主自身理解，同时结合《Instruction of Algorithm (4th Edition)》和《算法导论》（第三版）编写。本书是利用 CPP 完成的语法编写内容，同时也是 CPP算法学习的一本书，内容以龙书中的算法开始学习，由浅入深，配合一些 CPP 的内容，完成算法的初步学习和理解。PS：借鉴了很多原书中的内容，因为写的太好了……本文章中，将上">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://polaris516.github.io/img/Algorithm.png">
<meta property="article:published_time" content="2024-10-04T08:59:08.000Z">
<meta property="article:modified_time" content="2025-03-21T13:27:07.957Z">
<meta property="article:author" content="启明星_Polaris">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://polaris516.github.io/img/Algorithm.png">
  
  
  
  <title>Instruction of Algorithm - 一个程序员的简单博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"polaris516.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>启明星_Polaris</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>主页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>档案</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>目录</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Instruction of Algorithm"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-10-04 16:59" pubdate>
          2024年10月4日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          3.7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          31 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Instruction of Algorithm</h1>
            
            
              <div class="markdown-body">
                
                <p><img src="/img/AllAlgorithm.png" srcset="/img/loading.gif" lazyload alt="《Instruction of Algorithm (Fourth Edition)》"></p>
<p><img src="/img/Algorithm2.png" srcset="/img/loading.gif" lazyload alt="《算法导论》（第3版）"></p>
<div class="note note-warning">
            <p>本文内容根据博主自身理解，同时结合《Instruction of Algorithm (4th Edition)》和《算法导论》（第三版）编写。</p><p>本书是利用 CPP 完成的语法编写内容，同时也是 CPP算法学习的一本书，内容以龙书中的算法开始学习，由浅入深，配合一些 CPP 的内容，完成算法的初步学习和理解。</p><p>PS：借鉴了很多原书中的内容，因为写的太好了……</p><p>本文章中，将上面两部书简称为‘龙书’</p>
          </div>
<h2 id="Part-1-The-Role-of-Algorithms-in-Computing">Part 1 The Role of Algorithms in Computing</h2>
<h3 id="1-Algorithms">1. Algorithms</h3>
<p><strong>算法</strong>：（非形式的说）就是定义任何良定义的计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出。</p>
<p><code>Informally, an algorithm is any well-defined computational procedure that takes some value, or set of values, as input and produces some value, or set of values, as output in a finite amount of time.</code></p>
<p><strong>输入</strong></p>
<p><strong>输出</strong></p>
<h2 id="Part-2-Getting-Started">Part 2 Getting Started</h2>
<h3 id="Sort-Algorithm">Sort Algorithm</h3>
<p><a href="https://Polaris516.github.io/SortAlgorithm/">手撕排序算法</a></p>
<p><code>PS：这里的排序算法会用到后面的分治，递归等重要思想，可以提前了解一下排序算法，在后面的学习中，再次看排序算法你会收获更多。</code></p>
<h3 id="Binary-Search">Binary Search</h3>
<p><strong>二分查找：</strong></p>
<p>二分查找是一种在有序数组中快速查找目标值的算法，通过不断缩小搜索范围（每次排除一半的元素），时间复杂度为 O(log n)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> target)</span> </span>&#123;<br>	<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>	<span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>		<span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br>		<span class="hljs-keyword">if</span>(nums[mid] == target) &#123;<br>			<span class="hljs-keyword">return</span> mid;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target) &#123;<br>			left = mid + <span class="hljs-number">1</span>;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			right = mid - <span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>&#125;;<br>	cout &lt;&lt; <span class="hljs-built_in">binarySearch</span>(nums, <span class="hljs-number">5</span>) &lt;&lt; endl;   <span class="hljs-comment">// ?? 2</span><br>	cout &lt;&lt; <span class="hljs-built_in">binarySearch</span>(nums, <span class="hljs-number">9</span>) &lt;&lt; endl;   <span class="hljs-comment">// ?? 4</span><br>	cout &lt;&lt; <span class="hljs-built_in">binarySearch</span>(nums, <span class="hljs-number">2</span>) &lt;&lt; endl;   <span class="hljs-comment">// ?? -1(???)</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 二分查找的前提条件就是数组必须有序（可以是从大到小或者从小到大，按照情况调节代码</span><br></code></pre></td></tr></table></figure>
<hr>
<h2 id="Part-3-The-Divide-And-Conquer-method">Part 3 The Divide-And-Conquer method</h2>
<p><code>The divide-and-conquer method</code>：they break the problem into several subproblems that are similar to the original problem  but smaller in size, solve the subproblems recursively, and  then combine these solutions to create a solution to the original problem. In the divide-and-conquer method, if the problem is small enough—the base case—you just solve it directly without recursing.</p>
<p><code>分治策略</code>：将原来的问题拆解成和原问题相同的子问题，规模上变小使得可以通过解决子问题，将答案整合变成原问题的解。</p>
<p><code>Divide</code>: the problem into one or more subproblems that are smaller instances of the same problem.</p>
<p><code>Conquer</code>: the subproblem solutions to form a solution to the original problem.</p>
<p><code>Combine</code>: the subproblem solutions to form a solution to the original problem.</p>
<p><code>分</code>：将问题拆分成一个或若干个子问题，子问题与原问题形式相同，规模更小。</p>
<p><code>治</code>：子问题的解就是原问题的部分解</p>
<p><code>合</code>：子问题的解合并即是原问题的解</p>
<p><strong>特点：</strong></p>
<blockquote>
<ol>
<li>子问题之间相互独立，无重叠</li>
<li>通常不需要存储中间结果，直接通过递归逐层解决</li>
<li>适用于分解后子问题规模均衡的场景</li>
</ol>
</blockquote>
<p>[^divide-and-conquer algorithms partition the problem into disjoint subproblems, solve the subproblems recursively, and the combine their solutions to solve the original problem. In contrast dynamic programming applies when the subproblems overlap-that is ,when subproblems share subproblem.  --DP(instructions)]:</p>
<hr>
<h2 id="Part-4-Dynamic-Programming">Part 4 Dynamic Programming</h2>
<p><code>Dynamic Programming</code> applies when the subproblems overlap-that is ,when subproblems share subproblem. A dynamic-programming algorithm solves each subproblem just once and then saves its answer in a table, thereby  avoiding the work of recomputing the answer every time if solves each subproblem.</p>
<p><code>动态规划</code>：DP适用于子问题重叠的情况–即共享子问题，动态规划将每次解决的子问题存储到一个表中，以免它被重复计算</p>
<blockquote>
<p>To develop a dynamic-programming algorithm, follow a sequence of four steps:</p>
<ol>
<li>
<p>Characterize the structure of an optimal solution.</p>
</li>
<li>
<p>Recursively define the value of an optimal solution.3. Compute the value of an optimal solution,typically in a bottom up fashion.</p>
</li>
<li>
<p>Construct an optimal solution from computed information.</p>
</li>
</ol>
</blockquote>
<h3 id="动态规划的核心思想：">动态规划的核心思想：</h3>
<ol>
<li>拆分问题：将大问题拆分成一个个的小问题</li>
<li>记录状态：每一个子问题得到的状态一般都记录在一个DP数组中，或者是通过栈、队列等其他方式去记录</li>
<li>DP无后效性，按照一定顺序去求解拆分后的小问题。当小问题的状态或者结果得到了之后，我们就不去关心它是怎样得到的</li>
</ol>
<h3 id="动态规划的解决方法（3-1）">动态规划的解决方法（3+1）</h3>
<ol>
<li>首先将一个大问题拆解成小问题，接下来确定每个小问题解决之后得到的结果表示什么，即<font color=red>确定每个小问题的状态</font>，例如费波纳茨数列中，DP[i] 表示前 i 个数的某种方法的个数。这里我们可以想象成多米诺骨牌，在多米诺骨牌中就是需要你清楚每张牌代表什么</li>
<li>确立每个状态之间的关系，在搭建多米诺骨牌的时候，你需要利用某种方法将其摆好，也就是可以保证它能够连续倒塌，这也就是问题中每个子问题中存在的联系——状态转移方程</li>
<li>确立初始状态，当你已经找到状态转移方程，完成你的多米诺骨牌，要让它开始完成倒下的任务时，你需要给他一个初始状态，也就是你需要推他一把，正如物理学中所讲，力不会平白无故出现，所以在DP问题中，你需要找到并且完成初始状态的分配，<font color = red>即确立边界条件</font></li>
<li>算法优化（目前先不涉及）</li>
</ol>
<h3 id="Surface-learning：">Surface-learning：</h3>
<p>下面我们通过几个浅显的例子，先来简单看看 DP 问题，然后通过龙书上面的内容，深入学习DP。</p>
<h4 id="0-1背包问题（简单理解——DP二维数组的内涵）">0-1背包问题（简单理解——DP二维数组的内涵）</h4>
<p>给你一个可装载容量为W的背包和N个物品，每个物品有重量和价值两个属性。其中第i个物品的重量为wt[i]，价值为va[i]，现在让你用这个背包装物品，最多能装的价值是多少?<br>
在这里将问题具体化：现在有4 (N=4)个物品，背包总容量为8 (W=8),背包最多能装入价值为多少的物品?<br>
物体编号	物体体积	物体价值<br>
1					2					3<br>
2					3					4<br>
3					4					5<br>
4					5					6</p>
<img src="D:/ProgramData/Myblog/source/_posts/assets/image-20240405225918312.png" srcset="/img/loading.gif" lazyload alt="image-20240405225918312" style="zoom:50%;" />
<hr>
<h2 id="Part-5-Greedy-Algorithms">Part 5 Greedy Algorithms</h2>
<p>贪心算法：是一种通过每一步选择当前局部最优解，最终希望达到全局最优解的算法设计思想。其核心在于每一步决策中不考虑未来可能的后果，只关注当下能做出的最优选择。</p>
<p><strong>核心思想：</strong></p>
<ol>
<li>局部最优选择：每一步选择当前状态下看起来最好的决策（无需考虑后续影响）</li>
<li>无后效性：一旦做出选择，后续的子问题仅基于当前状态，不受之前决策的影响</li>
<li>期望全局最优：通过一系列局部最优选择，希望最终得到全局最优解（但需通过数学证明其正确性）</li>
</ol>
<p><strong>关键特征：</strong></p>
<ul>
<li>贪心选择性质：每一步的局部最优选择能导致全局最优解</li>
<li>最优子结构：问题的最优解包含其子问题的最优解（与动态规划类似，但无需存储中间状态）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1031">NOIP 2002 提高组] 均分纸牌 - 洛谷</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这道题只是简单理解一下贪心的过程：在这道题中什么是贪心呢？当然就是不管全局什么情况，当前位置下的那个数它必须是平均数：也就是说局部最优，问题中清晰的描述最后的排列肯定是N个数的值相同，这样我们求出平均数，只要保证当前位置的数是平均数即可。</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; number;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> N,avg;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>,cnt = <span class="hljs-number">0</span>,prefix = <span class="hljs-number">0</span>;<br>   	<br>    cin &gt;&gt; N;<br>    number.<span class="hljs-built_in">resize</span>(N + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)&#123;<br>        cin &gt;&gt; number[i];<br>        sum += number[i];<br>    &#125;<br>    <br>    avg = sum / N; <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)&#123;<br>		prefix += number[i] - avg; <span class="hljs-comment">// 这里我们模拟了一个牌堆，也就是说需要牌的时候，就跟牌堆要牌，多余牌就往牌堆扔牌，要注意扔牌和借牌都算是一种移动，想一下，正常情况下只能左右移动的时候，移出和移入都个算是一步。</span><br>        <span class="hljs-keyword">if</span>(prefix != <span class="hljs-number">0</span> &amp;&amp; i &lt; N - <span class="hljs-number">1</span>)&#123;<br>			cnt++;				<span class="hljs-comment">// 若牌堆不为0则我们由题可知肯定没结束，但是某些情况下在未完成任务就出现了prefix为0的情况，这样我们还需要设置另一个附加条件即当前位置不是倒数第二</span><br>        &#125;<br>    &#125;<br>    cout &lt;&lt; cnt &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 这里我们想一想：题目给出的是只能相邻移动，那如果是可以任意移动呢？</span><br><span class="hljs-comment">// 相邻移动: 你往牌堆扔牌和取牌个是一步</span><br><span class="hljs-comment">// 任意移动：你不用往牌堆扔牌，你直接扔给缺牌的即可</span><br></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1208">USACO1.3] 混合牛奶 Mixing Milk - 洛谷</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Farmer</span> &#123;<br>	<span class="hljs-type">int</span> price;<br>	<span class="hljs-type">int</span> output;<br>&#125;;	<span class="hljs-comment">// 定义结构体以及结构体属性</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> Farmer &amp;a, <span class="hljs-type">const</span> Farmer &amp;b)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span>(a.price != b.price) <span class="hljs-keyword">return</span> a.price &lt; b.price;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.output &gt; b.output;<br>&#125;	<span class="hljs-comment">// 重定义比较函数</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-type">int</span> required,number;<br>	<span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><br>	cin &gt;&gt; required &gt;&gt; number;<br>	<span class="hljs-function">vector&lt;Farmer&gt; <span class="hljs-title">farmers</span><span class="hljs-params">(number)</span></span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++) &#123;<br>		cin &gt;&gt; farmers[i].price &gt;&gt; farmers[i].output;<br>	&#125;<br>	<span class="hljs-built_in">sort</span>(farmers.<span class="hljs-built_in">begin</span>(),farmers.<span class="hljs-built_in">end</span>(),cmp);<br><br>	<span class="hljs-type">int</span> remaining = required;<br><br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; number &amp;&amp; remaining &gt; <span class="hljs-number">0</span>; ++j) &#123;<br>		<span class="hljs-type">int</span> buy = <span class="hljs-built_in">min</span>(farmers[j].output,remaining);<br>		sum += buy * farmers[j].price;<br>		remaining -= buy;<br>	&#125; <span class="hljs-comment">// 利用min函数可以省去一些计算过程，然后求值即可，因为你的价格已经按照从低到高完成排序</span><br><br>	cout &lt;&lt; sum &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 本题的贪心思路：若优先购买价格低的牛奶，由于总量不变，故局部最优累计可以达到全局最优效果。</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>在这里我们可以看到一个基本的贪心思路：</p>
<ul>
<li>定义一个结构体，确定该结构体的属性</li>
<li>在某些贪心思路下，对结构体中的属性按照要求完成排序（这里可以直接使用<algorithm>里面的 sort 完成排序，我们只要完成它里面的比较函数的逻辑编写）</li>
<li>按照题目所说完成算法</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">push_back</span>() 在Vector最后添加一个元素（参数为要插入的值）<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="Part-6-Elementary-Graph-Algorithms">Part 6 Elementary Graph Algorithms</h2>
<h3 id="Breadth-first-search">Breadth-first search</h3>
<p>**核心思想：**BFS是一种逐层遍历的算法，从起点出发，先访问所有距离为1的节点，再访问所有距离为2的节点，以此类推。适合解决最短路径问题。</p>
<blockquote>
<p>算法步骤：</p>
<ol>
<li>初始化队列，将起点加入队列并标记为已访问</li>
<li>从队列中取出一个节点，访问其所有未访问的邻接节点，将它们加入队列并标记</li>
<li>重复步骤2直至队列为空</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp;graph)</span></span>&#123;<br>	<span class="hljs-type">int</span> V = graph.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(V,<span class="hljs-literal">false</span>)</span></span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <br>    visited[start] = <span class="hljs-literal">true</span>;<br>    q.<span class="hljs-built_in">push</span>(start);<br>    <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cout &lt;&lt; u &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:graph[u])&#123;<br>            <span class="hljs-keyword">if</span>(!visited[v])&#123;<br>                visited[v] = <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(v);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>     <span class="hljs-comment">// 图的邻接表表示（5个节点）</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph = &#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,     <span class="hljs-comment">// 节点0的邻居</span><br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,  <span class="hljs-comment">// 节点1的邻居</span><br>        &#123;<span class="hljs-number">0</span>&#125;,        <span class="hljs-comment">// 节点2的邻居</span><br>        &#123;<span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 节点3的邻居</span><br>        &#123;<span class="hljs-number">1</span>&#125;         <span class="hljs-comment">// 节点4的邻居</span><br>    &#125;;<br>    cout &lt;&lt; <span class="hljs-string">&quot;BFS遍历顺序（从节点0开始）：&quot;</span>;<br>    <span class="hljs-built_in">BFS</span>(<span class="hljs-number">0</span>,graph); <span class="hljs-comment">// 输出：0 1 2 3 4</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Depth-first-search">Depth-first search</h3>
<p>**核心思想：**DFS是一种尽可能深的搜索算法，沿着一条路径走到尽头，然后回溯到最近未访问节点继续搜索。适合解决连通性问题、拓扑排序、回溯问题。</p>
<blockquote>
<p>算法步骤：（递归）</p>
<ol>
<li>从起点出发，标记为已访问</li>
<li>递归访问当前结点的所有未访问邻接节点</li>
<li>回溯到上一个节点继续搜索</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">const</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph,vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited)</span></span>&#123;<br>	visited[u] = <span class="hljs-literal">true</span>;<br>    cout &lt;&lt; u &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:graph[u])&#123;<br>        <span class="hljs-keyword">if</span>(!visited[v])&#123;<br>            <span class="hljs-built_in">DFS</span>(v,graph,visited);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-comment">// 图的邻接表表示（与BFS示例相同）</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph = &#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,     <span class="hljs-comment">// 节点0的邻居</span><br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,  <span class="hljs-comment">// 节点1的邻居</span><br>        &#123;<span class="hljs-number">0</span>&#125;,        <span class="hljs-comment">// 节点2的邻居</span><br>        &#123;<span class="hljs-number">1</span>&#125;,        <span class="hljs-comment">// 节点3的邻居</span><br>        &#123;<span class="hljs-number">1</span>&#125;         <span class="hljs-comment">// 节点4的邻居</span><br>    &#125;;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(graph.size(), <span class="hljs-literal">false</span>)</span></span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;DFS遍历顺序（从节点0开始）: &quot;</span>;<br>    <span class="hljs-built_in">DFS</span>(<span class="hljs-number">0</span>, graph, visited); <span class="hljs-comment">// 输出: 0 1 3 4 2 </span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>EG：现在要求输入一个数字，然后对这个数字进行全排列并且输出出来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; data;<br>vector&lt;<span class="hljs-type">bool</span>&gt; mark;<br><span class="hljs-type">int</span> end_position;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> pre_position)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(pre_position == end_position)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; end_position; i++)&#123;<br>            cout &lt;&lt; data[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= end_position; i++)&#123;<br>        <span class="hljs-keyword">if</span>(!mark[i])&#123;<br>            mark[i] = <span class="hljs-literal">true</span>;<br>            data[pre_position] = i;<br>            <span class="hljs-built_in">DFS</span>(pre_position + <span class="hljs-number">1</span>);<br>            <br>            mark[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin &gt;&gt; end_position;<br>    data.<span class="hljs-built_in">resize</span>(end_position);        <span class="hljs-comment">// 提前分配存储空间</span><br>    mark.<span class="hljs-built_in">resize</span>(end_position + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// +1是为了能存放下标end_position</span><br>    <span class="hljs-built_in">DFS</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,k,result = <span class="hljs-number">0</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; nums;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= x; i++)&#123;<br>        <span class="hljs-keyword">if</span>(x % i == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 判断一个数是否为素数：对这个数进行循环取余，若在某值下取余为0，也就是说可以整除那么则说明不是素数。</span><br><span class="hljs-comment">// 对这个判断素数的算法进行优化，就是优化它的循环次数，若一个数不是素数，必存在一个因数对 (a,b) 满足 a ≤ √n 且 b ≥ √n。因此只需检查 2 ≤ i ≤ √n 的范围即可。</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> count,<span class="hljs-type">int</span> sum)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(count == k)&#123;<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">is_prime</span>(sum))<br>            result++;<br>    	<span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = start; i &lt; n; i++)&#123;<br>        <span class="hljs-built_in">DFS</span>(i + <span class="hljs-number">1</span>, count + <span class="hljs-number">1</span>, sum + nums[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    nums.<span class="hljs-built_in">resize</span>(n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        cin &gt;&gt; nums[i];<br>    &#125;<br>    <span class="hljs-built_in">DFS</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    cout &lt;&lt; result &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>其实通过代码可以总结一下DFS一些基本的规律：</p>
<ol>
<li>DFS目前其实就是由两部分组成：递归和跳出</li>
<li>递归：根据某些场景的需要，利用参数的不同来实现循环递归调用</li>
<li>跳出：当到达最深处或者是场景需求下的位置时，完成场景下的任务，跳出递归，返回到上一层级，继续递归，直至所有任务完成。</li>
</ol>
</blockquote>
<p>对于这两个例题的选择，我们可以发现有一个标记数组，这也就是去重，在DFS或者其他所有算法中进行优化的剪枝效果。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1135">P1135 奇怪的电梯 - 洛谷</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;climits&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> N,A,B;<br>vector&lt;<span class="hljs-type">int</span>&gt; K;<br>vector&lt;<span class="hljs-type">int</span>&gt; min_steps;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> current_floor,<span class="hljs-type">int</span> step)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(step &gt;= min_steps[current_floor])&#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125; <span class="hljs-comment">// 剪枝：若当前的步数已经大于最小步数，那么再往后在进行计算就没有必要</span><br>    <br>    min_steps[current_floor] = step;<br>    <span class="hljs-comment">// 向上走</span><br>    <span class="hljs-type">int</span> next_floor = current_floor + K[current_floor];<br>    <span class="hljs-keyword">if</span>(next_floor &lt;= N &amp;&amp; step + <span class="hljs-number">1</span> &lt; min_steps[next_floor])&#123;<br>        <span class="hljs-built_in">DFS</span>(next_floor,step + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 向下走</span><br>    next_floor = current_floor - K[current_floor];<br>    <span class="hljs-keyword">if</span>(next_floor &gt;= <span class="hljs-number">1</span> &amp;&amp; step + <span class="hljs-number">1</span> &lt; min_steps[next_floor])&#123;<br>        <span class="hljs-built_in">DFS</span>(next_floor,step  + <span class="hljs-number">1</span>);<br>    &#125;	<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; N &gt;&gt; A &gt;&gt; B;<br>    <br>    K.<span class="hljs-built_in">resize</span>(N + <span class="hljs-number">1</span>);<br>    min_steps.<span class="hljs-built_in">resize</span>(N + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)&#123;<br>        cin &gt;&gt; K[i];<br>        min_steps[i] = INT_MAX;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(A == B)&#123;<br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-comment">// 特殊情况：起始值和结束值一样。</span><br>    <br>    <span class="hljs-built_in">DFS</span>(A,<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">if</span>(min_steps[B] != INT_MAX)&#123;<br>        cout &lt;&lt; min_steps[B] &lt;&lt; endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的深度搜索 + 剪枝很像 DP 的思想</p>
<hr>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Algorithm/" class="print-no-link">#Algorithm</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Instruction of Algorithm</div>
      <div>http://polaris516.github.io/Algorithm/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>启明星_Polaris</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年10月4日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/System/" title="System Operation">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">System Operation</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://DoubleXin516.github.io" target="_blank" rel="nofollow noopener"><span>启明星_Polaris</span></a> <i class="iconfont icon-love"></i> <a href="https://DoubleXin516.github.io/about/" target="_blank" rel="nofollow noopener"><span>更多</span></a>
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
